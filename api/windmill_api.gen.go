// Package windmill_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package windmill_api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for AppWithLastVersionExecutionMode.
const (
	AppWithLastVersionExecutionModeAnonymous AppWithLastVersionExecutionMode = "anonymous"
	AppWithLastVersionExecutionModePublisher AppWithLastVersionExecutionMode = "publisher"
	AppWithLastVersionExecutionModeViewer    AppWithLastVersionExecutionMode = "viewer"
)

// Defines values for AuditLogActionKind.
const (
	AuditLogActionKindCreated AuditLogActionKind = "Created"
	AuditLogActionKindDelete  AuditLogActionKind = "Delete"
	AuditLogActionKindExecute AuditLogActionKind = "Execute"
	AuditLogActionKindUpdated AuditLogActionKind = "Updated"
)

// Defines values for AuditLogOperation.
const (
	JobsRun          AuditLogOperation = "jobs.run"
	ScriptsCreate    AuditLogOperation = "scripts.create"
	ScriptsUpdate    AuditLogOperation = "scripts.update"
	UsersCreate      AuditLogOperation = "users.create"
	UsersDelete      AuditLogOperation = "users.delete"
	UsersLogin       AuditLogOperation = "users.login"
	UsersSetpassword AuditLogOperation = "users.setpassword"
	UsersTokenCreate AuditLogOperation = "users.token.create"
	UsersTokenDelete AuditLogOperation = "users.token.delete"
	UsersUpdate      AuditLogOperation = "users.update"
	VariablesCreate  AuditLogOperation = "variables.create"
	VariablesDelete  AuditLogOperation = "variables.delete"
	VariablesUpdate  AuditLogOperation = "variables.update"
)

// Defines values for BranchAllType.
const (
	Branchall BranchAllType = "branchall"
)

// Defines values for BranchOneType.
const (
	Branchone BranchOneType = "branchone"
)

// Defines values for CompletedJobJobKind.
const (
	CompletedJobJobKindDependencies CompletedJobJobKind = "dependencies"
	CompletedJobJobKindFlow         CompletedJobJobKind = "flow"
	CompletedJobJobKindFlowpreview  CompletedJobJobKind = "flowpreview"
	CompletedJobJobKindIdentity     CompletedJobJobKind = "identity"
	CompletedJobJobKindPreview      CompletedJobJobKind = "preview"
	CompletedJobJobKindScript       CompletedJobJobKind = "script"
	CompletedJobJobKindScriptHub    CompletedJobJobKind = "script_hub"
)

// Defines values for CompletedJobLanguage.
const (
	CompletedJobLanguageBash    CompletedJobLanguage = "bash"
	CompletedJobLanguageDeno    CompletedJobLanguage = "deno"
	CompletedJobLanguageGo      CompletedJobLanguage = "go"
	CompletedJobLanguagePython3 CompletedJobLanguage = "python3"
)

// Defines values for FlowStatusFailureModuleBranchChosenType.
const (
	FlowStatusFailureModuleBranchChosenTypeBranch  FlowStatusFailureModuleBranchChosenType = "branch"
	FlowStatusFailureModuleBranchChosenTypeDefault FlowStatusFailureModuleBranchChosenType = "default"
)

// Defines values for FlowStatusFailureModuleType.
const (
	FlowStatusFailureModuleTypeFailure              FlowStatusFailureModuleType = "Failure"
	FlowStatusFailureModuleTypeInProgress           FlowStatusFailureModuleType = "InProgress"
	FlowStatusFailureModuleTypeSuccess              FlowStatusFailureModuleType = "Success"
	FlowStatusFailureModuleTypeWaitingForEvents     FlowStatusFailureModuleType = "WaitingForEvents"
	FlowStatusFailureModuleTypeWaitingForExecutor   FlowStatusFailureModuleType = "WaitingForExecutor"
	FlowStatusFailureModuleTypeWaitingForPriorSteps FlowStatusFailureModuleType = "WaitingForPriorSteps"
)

// Defines values for FlowStatusModuleBranchChosenType.
const (
	FlowStatusModuleBranchChosenTypeBranch  FlowStatusModuleBranchChosenType = "branch"
	FlowStatusModuleBranchChosenTypeDefault FlowStatusModuleBranchChosenType = "default"
)

// Defines values for FlowStatusModuleType.
const (
	FlowStatusModuleTypeFailure              FlowStatusModuleType = "Failure"
	FlowStatusModuleTypeInProgress           FlowStatusModuleType = "InProgress"
	FlowStatusModuleTypeSuccess              FlowStatusModuleType = "Success"
	FlowStatusModuleTypeWaitingForEvents     FlowStatusModuleType = "WaitingForEvents"
	FlowStatusModuleTypeWaitingForExecutor   FlowStatusModuleType = "WaitingForExecutor"
	FlowStatusModuleTypeWaitingForPriorSteps FlowStatusModuleType = "WaitingForPriorSteps"
)

// Defines values for ForloopFlowType.
const (
	Forloopflow ForloopFlowType = "forloopflow"
)

// Defines values for GlobalUserInfoLoginType.
const (
	Github   GlobalUserInfoLoginType = "github"
	Password GlobalUserInfoLoginType = "password"
)

// Defines values for IdentityType.
const (
	IdentityTypeIdentity IdentityType = "identity"
)

// Defines values for JavascriptTransformType.
const (
	JavascriptTransformTypeJavascript JavascriptTransformType = "javascript"
)

// Defines values for ListableAppExecutionMode.
const (
	ListableAppExecutionModeAnonymous ListableAppExecutionMode = "anonymous"
	ListableAppExecutionModePublisher ListableAppExecutionMode = "publisher"
	ListableAppExecutionModeViewer    ListableAppExecutionMode = "viewer"
)

// Defines values for MainArgSignatureType.
const (
	Invalid MainArgSignatureType = "Invalid"
	Valid   MainArgSignatureType = "Valid"
)

// Defines values for PathFlowType.
const (
	PathFlowTypeFlow PathFlowType = "flow"
)

// Defines values for PathScriptType.
const (
	PathScriptTypeScript PathScriptType = "script"
)

// Defines values for PolicyExecutionMode.
const (
	Anonymous PolicyExecutionMode = "anonymous"
	Publisher PolicyExecutionMode = "publisher"
	Viewer    PolicyExecutionMode = "viewer"
)

// Defines values for PreviewLanguage.
const (
	PreviewLanguageBash    PreviewLanguage = "bash"
	PreviewLanguageDeno    PreviewLanguage = "deno"
	PreviewLanguageGo      PreviewLanguage = "go"
	PreviewLanguagePython3 PreviewLanguage = "python3"
)

// Defines values for QueuedJobJobKind.
const (
	QueuedJobJobKindDependencies QueuedJobJobKind = "dependencies"
	QueuedJobJobKindFlow         QueuedJobJobKind = "flow"
	QueuedJobJobKindFlowpreview  QueuedJobJobKind = "flowpreview"
	QueuedJobJobKindIdentity     QueuedJobJobKind = "identity"
	QueuedJobJobKindPreview      QueuedJobJobKind = "preview"
	QueuedJobJobKindScript       QueuedJobJobKind = "script"
	QueuedJobJobKindScriptHub    QueuedJobJobKind = "script_hub"
)

// Defines values for QueuedJobLanguage.
const (
	QueuedJobLanguageBash    QueuedJobLanguage = "bash"
	QueuedJobLanguageDeno    QueuedJobLanguage = "deno"
	QueuedJobLanguageGo      QueuedJobLanguage = "go"
	QueuedJobLanguagePython3 QueuedJobLanguage = "python3"
)

// Defines values for RawScriptLanguage.
const (
	RawScriptLanguageBash    RawScriptLanguage = "bash"
	RawScriptLanguageDeno    RawScriptLanguage = "deno"
	RawScriptLanguageGo      RawScriptLanguage = "go"
	RawScriptLanguagePython3 RawScriptLanguage = "python3"
)

// Defines values for RawScriptType.
const (
	Rawscript RawScriptType = "rawscript"
)

// Defines values for RunnableType.
const (
	RunnableTypeFlowPath   RunnableType = "FlowPath"
	RunnableTypeScriptHash RunnableType = "ScriptHash"
	RunnableTypeScriptPath RunnableType = "ScriptPath"
)

// Defines values for ScriptKind.
const (
	ScriptKindApproval ScriptKind = "approval"
	ScriptKindCommand  ScriptKind = "command"
	ScriptKindFailure  ScriptKind = "failure"
	ScriptKindScript   ScriptKind = "script"
	ScriptKindTrigger  ScriptKind = "trigger"
)

// Defines values for ScriptLanguage.
const (
	Bash    ScriptLanguage = "bash"
	Deno    ScriptLanguage = "deno"
	Go      ScriptLanguage = "go"
	Python3 ScriptLanguage = "python3"
)

// Defines values for StaticTransformType.
const (
	StaticTransformTypeJavascript StaticTransformType = "javascript"
)

// Defines values for ActionKind.
const (
	ActionKindCreate  ActionKind = "Create"
	ActionKindDelete  ActionKind = "Delete"
	ActionKindExecute ActionKind = "Execute"
	ActionKindUpdate  ActionKind = "Update"
)

// AppWithLastVersion defines model for AppWithLastVersion.
type AppWithLastVersion struct {
	CreatedAt     time.Time                       `json:"created_at"`
	CreatedBy     string                          `json:"created_by"`
	ExecutionMode AppWithLastVersionExecutionMode `json:"execution_mode"`
	ExtraPerms    AppWithLastVersion_ExtraPerms   `json:"extra_perms"`
	Id            int                             `json:"id"`
	Path          string                          `json:"path"`
	Policy        Policy                          `json:"policy"`
	Summary       string                          `json:"summary"`
	Value         interface{}                     `json:"value"`
	Versions      []int                           `json:"versions"`
	WorkspaceId   string                          `json:"workspace_id"`
}

// AppWithLastVersionExecutionMode defines model for AppWithLastVersion.ExecutionMode.
type AppWithLastVersionExecutionMode string

// AppWithLastVersion_ExtraPerms defines model for AppWithLastVersion.ExtraPerms.
type AppWithLastVersion_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// AuditLog defines model for AuditLog.
type AuditLog struct {
	ActionKind AuditLogActionKind      `json:"action_kind"`
	Id         int                     `json:"id"`
	Operation  AuditLogOperation       `json:"operation"`
	Parameters *map[string]interface{} `json:"parameters,omitempty"`
	Resource   *string                 `json:"resource,omitempty"`
	Timestamp  time.Time               `json:"timestamp"`
	Username   string                  `json:"username"`
}

// AuditLogActionKind defines model for AuditLog.ActionKind.
type AuditLogActionKind string

// AuditLogOperation defines model for AuditLog.Operation.
type AuditLogOperation string

// BranchAll defines model for BranchAll.
type BranchAll struct {
	Branches []struct {
		Modules     []FlowModule `json:"modules"`
		SkipFailure *bool        `json:"skip_failure,omitempty"`
		Summary     *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Parallel *bool         `json:"parallel,omitempty"`
	Type     BranchAllType `json:"type"`
}

// BranchAllType defines model for BranchAll.Type.
type BranchAllType string

// BranchOne defines model for BranchOne.
type BranchOne struct {
	Branches []struct {
		Expr    string       `json:"expr"`
		Modules []FlowModule `json:"modules"`
		Summary *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Default []FlowModule  `json:"default"`
	Type    BranchOneType `json:"type"`
}

// BranchOneType defines model for BranchOne.Type.
type BranchOneType string

// CompletedJob defines model for CompletedJob.
type CompletedJob struct {
	Args           *ScriptArgs           `json:"args,omitempty"`
	Canceled       bool                  `json:"canceled"`
	CanceledBy     *string               `json:"canceled_by,omitempty"`
	CanceledReason *string               `json:"canceled_reason,omitempty"`
	CreatedAt      time.Time             `json:"created_at"`
	CreatedBy      string                `json:"created_by"`
	Deleted        *bool                 `json:"deleted,omitempty"`
	DurationMs     int                   `json:"duration_ms"`
	Email          string                `json:"email"`
	FlowStatus     *FlowStatus           `json:"flow_status,omitempty"`
	Id             openapi_types.UUID    `json:"id"`
	IsFlowStep     bool                  `json:"is_flow_step"`
	IsSkipped      bool                  `json:"is_skipped"`
	JobKind        CompletedJobJobKind   `json:"job_kind"`
	Language       *CompletedJobLanguage `json:"language,omitempty"`
	Logs           *string               `json:"logs,omitempty"`
	MemPeak        *int                  `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID   `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string       `json:"permissioned_as"`
	RawCode        *string      `json:"raw_code,omitempty"`
	RawFlow        *FlowValue   `json:"raw_flow,omitempty"`
	Result         *interface{} `json:"result,omitempty"`
	SchedulePath   *string      `json:"schedule_path,omitempty"`
	ScriptHash     *string      `json:"script_hash,omitempty"`
	ScriptPath     *string      `json:"script_path,omitempty"`
	StartedAt      time.Time    `json:"started_at"`
	Success        bool         `json:"success"`
	VisibleToOwner bool         `json:"visible_to_owner"`
	WorkspaceId    *string      `json:"workspace_id,omitempty"`
}

// CompletedJobJobKind defines model for CompletedJob.JobKind.
type CompletedJobJobKind string

// CompletedJobLanguage defines model for CompletedJob.Language.
type CompletedJobLanguage string

// ContextualVariable defines model for ContextualVariable.
type ContextualVariable struct {
	Description string `json:"description"`
	Name        string `json:"name"`
	Value       string `json:"value"`
}

// CreateInput defines model for CreateInput.
type CreateInput struct {
	Args map[string]interface{} `json:"args"`
	Name string                 `json:"name"`
}

// CreateResource defines model for CreateResource.
type CreateResource struct {
	Description  *string     `json:"description,omitempty"`
	Path         string      `json:"path"`
	ResourceType string      `json:"resource_type"`
	Value        interface{} `json:"value"`
}

// CreateVariable defines model for CreateVariable.
type CreateVariable struct {
	Account     *int   `json:"account,omitempty"`
	Description string `json:"description"`
	IsOauth     *bool  `json:"is_oauth,omitempty"`
	IsSecret    bool   `json:"is_secret"`
	Path        string `json:"path"`
	Value       string `json:"value"`
}

// CreateWorkspace defines model for CreateWorkspace.
type CreateWorkspace struct {
	Id       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

// EditResource defines model for EditResource.
type EditResource struct {
	Description *string      `json:"description,omitempty"`
	Path        *string      `json:"path,omitempty"`
	Value       *interface{} `json:"value,omitempty"`
}

// EditResourceType defines model for EditResourceType.
type EditResourceType struct {
	Description *string `json:"description,omitempty"`
	Schema      *string `json:"schema,omitempty"`
}

// EditSchedule defines model for EditSchedule.
type EditSchedule struct {
	Args     ScriptArgs `json:"args"`
	Schedule string     `json:"schedule"`
	Timezone string     `json:"timezone"`
}

// EditVariable defines model for EditVariable.
type EditVariable struct {
	Description *string `json:"description,omitempty"`
	IsSecret    *bool   `json:"is_secret,omitempty"`
	Path        *string `json:"path,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// EditWorkspaceUser defines model for EditWorkspaceUser.
type EditWorkspaceUser struct {
	Disabled *bool `json:"disabled,omitempty"`
	IsAdmin  *bool `json:"is_admin,omitempty"`
	Operator *bool `json:"operator,omitempty"`
}

// Flow defines model for Flow.
type Flow struct {
	AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
	Archived             bool                    `json:"archived"`
	Description          *string                 `json:"description,omitempty"`
	EditedAt             time.Time               `json:"edited_at"`
	EditedBy             string                  `json:"edited_by"`
	ExtraPerms           map[string]interface{}  `json:"extra_perms"`
	Path                 string                  `json:"path"`
	Schema               *map[string]interface{} `json:"schema,omitempty"`
	Starred              *bool                   `json:"starred,omitempty"`
	Summary              string                  `json:"summary"`
	Value                FlowValue               `json:"value"`
	WorkspaceId          *string                 `json:"workspace_id,omitempty"`
}

// FlowMetadata defines model for FlowMetadata.
type FlowMetadata struct {
	AdditionalProperties *bool                  `json:"additionalProperties,omitempty"`
	Archived             bool                   `json:"archived"`
	EditedAt             time.Time              `json:"edited_at"`
	EditedBy             string                 `json:"edited_by"`
	ExtraPerms           map[string]interface{} `json:"extra_perms"`
	Path                 string                 `json:"path"`
	Starred              *bool                  `json:"starred,omitempty"`
	WorkspaceId          *string                `json:"workspace_id,omitempty"`
}

// FlowModule defines model for FlowModule.
type FlowModule struct {
	Id          string          `json:"id"`
	Retry       *Retry          `json:"retry,omitempty"`
	Sleep       *InputTransform `json:"sleep,omitempty"`
	StopAfterIf *struct {
		Expr          string `json:"expr"`
		SkipIfStopped *bool  `json:"skip_if_stopped,omitempty"`
	} `json:"stop_after_if,omitempty"`
	Summary *string `json:"summary,omitempty"`
	Suspend *struct {
		RequiredEvents *int `json:"required_events,omitempty"`
		Timeout        *int `json:"timeout,omitempty"`
	} `json:"suspend,omitempty"`
	Value FlowModuleValue `json:"value"`
}

// FlowModuleValue defines model for FlowModuleValue.
type FlowModuleValue interface{}

// FlowPreview defines model for FlowPreview.
type FlowPreview struct {
	Args  ScriptArgs `json:"args"`
	Path  *string    `json:"path,omitempty"`
	Value FlowValue  `json:"value"`
}

// FlowStatus defines model for FlowStatus.
type FlowStatus struct {
	FailureModule struct {
		Approvers *[]struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers,omitempty"`
		BranchChosen *struct {
			Branch *int                                    `json:"branch,omitempty"`
			Type   FlowStatusFailureModuleBranchChosenType `json:"type"`
		} `json:"branch_chosen,omitempty"`
		Branchall *struct {
			Branch int `json:"branch"`
			Len    int `json:"len"`
		} `json:"branchall,omitempty"`
		Count    *int      `json:"count,omitempty"`
		FlowJobs *[]string `json:"flow_jobs,omitempty"`
		Id       *string   `json:"id,omitempty"`
		Iterator *struct {
			Args   *interface{}   `json:"args,omitempty"`
			Index  *int           `json:"index,omitempty"`
			Itered *[]interface{} `json:"itered,omitempty"`
		} `json:"iterator,omitempty"`
		Job          *openapi_types.UUID         `json:"job,omitempty"`
		ParentModule *string                     `json:"parent_module,omitempty"`
		Type         FlowStatusFailureModuleType `json:"type"`
	} `json:"failure_module"`
	Modules []FlowStatusModule `json:"modules"`
	Retry   *struct {
		FailCount  *int                  `json:"fail_count,omitempty"`
		FailedJobs *[]openapi_types.UUID `json:"failed_jobs,omitempty"`
	} `json:"retry,omitempty"`
	Step int `json:"step"`
}

// FlowStatusFailureModuleBranchChosenType defines model for FlowStatus.FailureModule.BranchChosen.Type.
type FlowStatusFailureModuleBranchChosenType string

// FlowStatusFailureModuleType defines model for FlowStatus.FailureModule.Type.
type FlowStatusFailureModuleType string

// FlowStatusModule defines model for FlowStatusModule.
type FlowStatusModule struct {
	Approvers *[]struct {
		Approver string `json:"approver"`
		ResumeId int    `json:"resume_id"`
	} `json:"approvers,omitempty"`
	BranchChosen *struct {
		Branch *int                             `json:"branch,omitempty"`
		Type   FlowStatusModuleBranchChosenType `json:"type"`
	} `json:"branch_chosen,omitempty"`
	Branchall *struct {
		Branch int `json:"branch"`
		Len    int `json:"len"`
	} `json:"branchall,omitempty"`
	Count    *int      `json:"count,omitempty"`
	FlowJobs *[]string `json:"flow_jobs,omitempty"`
	Id       *string   `json:"id,omitempty"`
	Iterator *struct {
		Args   *interface{}   `json:"args,omitempty"`
		Index  *int           `json:"index,omitempty"`
		Itered *[]interface{} `json:"itered,omitempty"`
	} `json:"iterator,omitempty"`
	Job  *openapi_types.UUID  `json:"job,omitempty"`
	Type FlowStatusModuleType `json:"type"`
}

// FlowStatusModuleBranchChosenType defines model for FlowStatusModule.BranchChosen.Type.
type FlowStatusModuleBranchChosenType string

// FlowStatusModuleType defines model for FlowStatusModule.Type.
type FlowStatusModuleType string

// FlowValue defines model for FlowValue.
type FlowValue struct {
	FailureModule *FlowModule  `json:"failure_module,omitempty"`
	Modules       []FlowModule `json:"modules"`
	SameWorker    *bool        `json:"same_worker,omitempty"`
}

// Folder defines model for Folder.
type Folder struct {
	ExtraPerms Folder_ExtraPerms `json:"extra_perms"`
	Name       string            `json:"name"`
	Owners     []string          `json:"owners"`
}

// Folder_ExtraPerms defines model for Folder.ExtraPerms.
type Folder_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ForloopFlow defines model for ForloopFlow.
type ForloopFlow struct {
	Iterator     InputTransform  `json:"iterator"`
	Modules      []FlowModule    `json:"modules"`
	Parallel     *bool           `json:"parallel,omitempty"`
	SkipFailures bool            `json:"skip_failures"`
	Type         ForloopFlowType `json:"type"`
}

// ForloopFlowType defines model for ForloopFlow.Type.
type ForloopFlowType string

// GlobalUserInfo defines model for GlobalUserInfo.
type GlobalUserInfo struct {
	Company    *string                 `json:"company,omitempty"`
	Email      string                  `json:"email"`
	LoginType  GlobalUserInfoLoginType `json:"login_type"`
	Name       *string                 `json:"name,omitempty"`
	SuperAdmin bool                    `json:"super_admin"`
	Verified   bool                    `json:"verified"`
}

// GlobalUserInfoLoginType defines model for GlobalUserInfo.LoginType.
type GlobalUserInfoLoginType string

// Group defines model for Group.
type Group struct {
	ExtraPerms *Group_ExtraPerms `json:"extra_perms,omitempty"`
	Members    *[]string         `json:"members,omitempty"`
	Name       string            `json:"name"`
	Summary    *string           `json:"summary,omitempty"`
}

// Group_ExtraPerms defines model for Group.ExtraPerms.
type Group_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Identity defines model for Identity.
type Identity struct {
	Flow *bool        `json:"flow,omitempty"`
	Type IdentityType `json:"type"`
}

// IdentityType defines model for Identity.Type.
type IdentityType string

// Input defines model for Input.
type Input struct {
	Args      map[string]interface{} `json:"args"`
	CreatedAt time.Time              `json:"created_at"`
	CreatedBy string                 `json:"created_by"`
	Id        string                 `json:"id"`
	IsPublic  bool                   `json:"is_public"`
	Name      string                 `json:"name"`
}

// InputTransform defines model for InputTransform.
type InputTransform interface{}

// JavascriptTransform defines model for JavascriptTransform.
type JavascriptTransform struct {
	Expr string                  `json:"expr"`
	Type JavascriptTransformType `json:"type"`
}

// JavascriptTransformType defines model for JavascriptTransform.Type.
type JavascriptTransformType string

// Job defines model for Job.
type Job interface{}

// ListableApp defines model for ListableApp.
type ListableApp struct {
	EditedAt      time.Time                `json:"edited_at"`
	ExecutionMode ListableAppExecutionMode `json:"execution_mode"`
	ExtraPerms    ListableApp_ExtraPerms   `json:"extra_perms"`
	Id            int                      `json:"id"`
	Path          string                   `json:"path"`
	Starred       *bool                    `json:"starred,omitempty"`
	Summary       string                   `json:"summary"`
	Version       int                      `json:"version"`
	WorkspaceId   string                   `json:"workspace_id"`
}

// ListableAppExecutionMode defines model for ListableApp.ExecutionMode.
type ListableAppExecutionMode string

// ListableApp_ExtraPerms defines model for ListableApp.ExtraPerms.
type ListableApp_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListableResource defines model for ListableResource.
type ListableResource struct {
	Account      *float32                     `json:"account,omitempty"`
	Description  *string                      `json:"description,omitempty"`
	ExtraPerms   *ListableResource_ExtraPerms `json:"extra_perms,omitempty"`
	IsExpired    *bool                        `json:"is_expired,omitempty"`
	IsLinked     bool                         `json:"is_linked"`
	IsOauth      bool                         `json:"is_oauth"`
	IsRefreshed  bool                         `json:"is_refreshed"`
	Path         string                       `json:"path"`
	RefreshError *string                      `json:"refresh_error,omitempty"`
	ResourceType string                       `json:"resource_type"`
	Value        *interface{}                 `json:"value,omitempty"`
	WorkspaceId  *string                      `json:"workspace_id,omitempty"`
}

// ListableResource_ExtraPerms defines model for ListableResource.ExtraPerms.
type ListableResource_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListableVariable defines model for ListableVariable.
type ListableVariable struct {
	Account      *int                        `json:"account,omitempty"`
	Description  *string                     `json:"description,omitempty"`
	ExtraPerms   ListableVariable_ExtraPerms `json:"extra_perms"`
	IsExpired    *bool                       `json:"is_expired,omitempty"`
	IsLinked     *bool                       `json:"is_linked,omitempty"`
	IsOauth      *bool                       `json:"is_oauth,omitempty"`
	IsRefreshed  *bool                       `json:"is_refreshed,omitempty"`
	IsSecret     bool                        `json:"is_secret"`
	Path         string                      `json:"path"`
	RefreshError *string                     `json:"refresh_error,omitempty"`
	Value        *string                     `json:"value,omitempty"`
	WorkspaceId  string                      `json:"workspace_id"`
}

// ListableVariable_ExtraPerms defines model for ListableVariable.ExtraPerms.
type ListableVariable_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Login defines model for Login.
type Login struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// MainArgSignature defines model for MainArgSignature.
type MainArgSignature struct {
	Args []struct {
		Default    *interface{} `json:"default,omitempty"`
		HasDefault *bool        `json:"has_default,omitempty"`
		Name       string       `json:"name"`
		Typ        interface{}  `json:"typ"`
	} `json:"args"`
	Error      string               `json:"error"`
	StarArgs   bool                 `json:"star_args"`
	StarKwargs *bool                `json:"star_kwargs,omitempty"`
	Type       MainArgSignatureType `json:"type"`
}

// MainArgSignatureType defines model for MainArgSignature.Type.
type MainArgSignatureType string

// NewSchedule defines model for NewSchedule.
type NewSchedule struct {
	Args       ScriptArgs `json:"args"`
	Enabled    *bool      `json:"enabled,omitempty"`
	IsFlow     bool       `json:"is_flow"`
	Path       string     `json:"path"`
	Schedule   string     `json:"schedule"`
	ScriptPath string     `json:"script_path"`
	Timezone   string     `json:"timezone"`
}

// NewToken defines model for NewToken.
type NewToken struct {
	Expiration *time.Time `json:"expiration,omitempty"`
	Label      *string    `json:"label,omitempty"`
}

// NewTokenImpersonate defines model for NewTokenImpersonate.
type NewTokenImpersonate struct {
	Expiration       *time.Time `json:"expiration,omitempty"`
	ImpersonateEmail string     `json:"impersonate_email"`
	Label            *string    `json:"label,omitempty"`
}

// NewUser defines model for NewUser.
type NewUser struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Username string `json:"username"`
}

// OpenFlow defines model for OpenFlow.
type OpenFlow struct {
	Description *string                 `json:"description,omitempty"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       FlowValue               `json:"value"`
}

// OpenFlowWPath defines model for OpenFlowWPath.
type OpenFlowWPath struct {
	Description *string                 `json:"description,omitempty"`
	Path        string                  `json:"path"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       FlowValue               `json:"value"`
}

// PathFlow defines model for PathFlow.
type PathFlow struct {
	InputTransforms PathFlow_InputTransforms `json:"input_transforms"`
	Path            string                   `json:"path"`
	Type            PathFlowType             `json:"type"`
}

// PathFlow_InputTransforms defines model for PathFlow.InputTransforms.
type PathFlow_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// PathFlowType defines model for PathFlow.Type.
type PathFlowType string

// PathScript defines model for PathScript.
type PathScript struct {
	Hash            *string                    `json:"hash,omitempty"`
	InputTransforms PathScript_InputTransforms `json:"input_transforms"`
	Path            string                     `json:"path"`
	Type            PathScriptType             `json:"type"`
}

// PathScript_InputTransforms defines model for PathScript.InputTransforms.
type PathScript_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// PathScriptType defines model for PathScript.Type.
type PathScriptType string

// Policy defines model for Policy.
type Policy struct {
	ExecutionMode   *PolicyExecutionMode `json:"execution_mode,omitempty"`
	OnBehalfOf      *string              `json:"on_behalf_of,omitempty"`
	OnBehalfOfEmail *string              `json:"on_behalf_of_email,omitempty"`
	Triggerables    *Policy_Triggerables `json:"triggerables,omitempty"`
}

// PolicyExecutionMode defines model for Policy.ExecutionMode.
type PolicyExecutionMode string

// Policy_Triggerables defines model for Policy.Triggerables.
type Policy_Triggerables struct {
	AdditionalProperties map[string]map[string]interface{} `json:"-"`
}

// Preview defines model for Preview.
type Preview struct {
	Args     ScriptArgs      `json:"args"`
	Content  string          `json:"content"`
	Language PreviewLanguage `json:"language"`
	Path     *string         `json:"path,omitempty"`
}

// PreviewLanguage defines model for Preview.Language.
type PreviewLanguage string

// QueuedJob defines model for QueuedJob.
type QueuedJob struct {
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	CreatedBy      *string             `json:"created_by,omitempty"`
	Email          string              `json:"email"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	JobKind        QueuedJobJobKind    `json:"job_kind"`
	Language       *QueuedJobLanguage  `json:"language,omitempty"`
	LastPing       *time.Time          `json:"last_ping,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	MemPeak        *int                `json:"mem_peak,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string     `json:"permissioned_as"`
	RawCode        *string    `json:"raw_code,omitempty"`
	RawFlow        *FlowValue `json:"raw_flow,omitempty"`
	Running        bool       `json:"running"`
	SchedulePath   *string    `json:"schedule_path,omitempty"`
	ScheduledFor   *time.Time `json:"scheduled_for,omitempty"`
	ScriptHash     *string    `json:"script_hash,omitempty"`
	ScriptPath     *string    `json:"script_path,omitempty"`
	StartedAt      *time.Time `json:"started_at,omitempty"`
	VisibleToOwner bool       `json:"visible_to_owner"`
	WorkspaceId    *string    `json:"workspace_id,omitempty"`
}

// QueuedJobJobKind defines model for QueuedJob.JobKind.
type QueuedJobJobKind string

// QueuedJobLanguage defines model for QueuedJob.Language.
type QueuedJobLanguage string

// RawScript defines model for RawScript.
type RawScript struct {
	Content         string                    `json:"content"`
	InputTransforms RawScript_InputTransforms `json:"input_transforms"`
	Language        RawScriptLanguage         `json:"language"`
	Lock            *string                   `json:"lock,omitempty"`
	Path            *string                   `json:"path,omitempty"`
	Type            RawScriptType             `json:"type"`
}

// RawScript_InputTransforms defines model for RawScript.InputTransforms.
type RawScript_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// RawScriptLanguage defines model for RawScript.Language.
type RawScriptLanguage string

// RawScriptType defines model for RawScript.Type.
type RawScriptType string

// Resource defines model for Resource.
type Resource struct {
	Description  *string              `json:"description,omitempty"`
	ExtraPerms   *Resource_ExtraPerms `json:"extra_perms,omitempty"`
	IsOauth      bool                 `json:"is_oauth"`
	Path         string               `json:"path"`
	ResourceType string               `json:"resource_type"`
	Value        *interface{}         `json:"value,omitempty"`
	WorkspaceId  *string              `json:"workspace_id,omitempty"`
}

// Resource_ExtraPerms defines model for Resource.ExtraPerms.
type Resource_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	Description *string      `json:"description,omitempty"`
	Name        string       `json:"name"`
	Schema      *interface{} `json:"schema,omitempty"`
	WorkspaceId *string      `json:"workspace_id,omitempty"`
}

// Retry defines model for Retry.
type Retry struct {
	Constant *struct {
		Attempts *int `json:"attempts,omitempty"`
		Seconds  *int `json:"seconds,omitempty"`
	} `json:"constant,omitempty"`
	Exponential *struct {
		Attempts   *int `json:"attempts,omitempty"`
		Multiplier *int `json:"multiplier,omitempty"`
		Seconds    *int `json:"seconds,omitempty"`
	} `json:"exponential,omitempty"`
}

// RunnableType defines model for RunnableType.
type RunnableType string

// Schedule defines model for Schedule.
type Schedule struct {
	Args       *ScriptArgs         `json:"args,omitempty"`
	EditedAt   time.Time           `json:"edited_at"`
	EditedBy   string              `json:"edited_by"`
	Email      string              `json:"email"`
	Enabled    bool                `json:"enabled"`
	Error      *string             `json:"error,omitempty"`
	ExtraPerms Schedule_ExtraPerms `json:"extra_perms"`
	IsFlow     bool                `json:"is_flow"`
	Path       string              `json:"path"`
	Schedule   string              `json:"schedule"`
	ScriptPath string              `json:"script_path"`
	Timezone   string              `json:"timezone"`
}

// Schedule_ExtraPerms defines model for Schedule.ExtraPerms.
type Schedule_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Script defines model for Script.
type Script struct {
	Archived      bool              `json:"archived"`
	Content       string            `json:"content"`
	CreatedAt     time.Time         `json:"created_at"`
	CreatedBy     string            `json:"created_by"`
	Deleted       bool              `json:"deleted"`
	Description   string            `json:"description"`
	ExtraPerms    Script_ExtraPerms `json:"extra_perms"`
	Hash          string            `json:"hash"`
	IsTemplate    bool              `json:"is_template"`
	Kind          ScriptKind        `json:"kind"`
	Language      ScriptLanguage    `json:"language"`
	Lock          *string           `json:"lock,omitempty"`
	LockErrorLogs *string           `json:"lock_error_logs,omitempty"`

	// The first element is the direct parent of the script, the second is the parent of the first, etc
	ParentHashes *[]string               `json:"parent_hashes,omitempty"`
	Path         string                  `json:"path"`
	Schema       *map[string]interface{} `json:"schema,omitempty"`
	Starred      bool                    `json:"starred"`
	Summary      string                  `json:"summary"`
	WorkspaceId  *string                 `json:"workspace_id,omitempty"`
}

// Script_ExtraPerms defines model for Script.ExtraPerms.
type Script_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ScriptKind defines model for Script.Kind.
type ScriptKind string

// ScriptLanguage defines model for Script.Language.
type ScriptLanguage string

// ScriptArgs defines model for ScriptArgs.
type ScriptArgs struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StaticTransform defines model for StaticTransform.
type StaticTransform struct {
	Type  StaticTransformType `json:"type"`
	Value *interface{}        `json:"value,omitempty"`
}

// StaticTransformType defines model for StaticTransform.Type.
type StaticTransformType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string    `json:"access_token"`
	ExpiresIn    *int      `json:"expires_in,omitempty"`
	RefreshToken *string   `json:"refresh_token,omitempty"`
	Scope        *[]string `json:"scope,omitempty"`
}

// TruncatedToken defines model for TruncatedToken.
type TruncatedToken struct {
	CreatedAt   time.Time  `json:"created_at"`
	Expiration  *time.Time `json:"expiration,omitempty"`
	Label       *string    `json:"label,omitempty"`
	LastUsedAt  time.Time  `json:"last_used_at"`
	TokenPrefix string     `json:"token_prefix"`
}

// UpdateInput defines model for UpdateInput.
type UpdateInput struct {
	Id       string `json:"id"`
	IsPublic bool   `json:"is_public"`
	Name     string `json:"name"`
}

// Usage defines model for Usage.
type Usage struct {
	Executions *float32 `json:"executions,omitempty"`
}

// User defines model for User.
type User struct {
	CreatedAt     time.Time `json:"created_at"`
	Disabled      bool      `json:"disabled"`
	Email         string    `json:"email"`
	Folders       []string  `json:"folders"`
	FoldersOwners []string  `json:"folders_owners"`
	Groups        *[]string `json:"groups,omitempty"`
	IsAdmin       bool      `json:"is_admin"`
	IsSuperAdmin  bool      `json:"is_super_admin"`
	Operator      bool      `json:"operator"`
	Usage         *Usage    `json:"usage,omitempty"`
	Username      string    `json:"username"`
}

// UserWorkspaceList defines model for UserWorkspaceList.
type UserWorkspaceList struct {
	Email      string `json:"email"`
	Workspaces []struct {
		Id       string `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
	} `json:"workspaces"`
}

// WorkerPing defines model for WorkerPing.
type WorkerPing struct {
	Ip             string    `json:"ip"`
	JobsExecuted   int       `json:"jobs_executed"`
	LastPing       *float32  `json:"last_ping,omitempty"`
	StartedAt      time.Time `json:"started_at"`
	Worker         string    `json:"worker"`
	WorkerInstance string    `json:"worker_instance"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	Domain *string `json:"domain,omitempty"`
	Id     string  `json:"id"`
	Name   string  `json:"name"`
	Owner  string  `json:"owner"`
}

// WorkspaceInvite defines model for WorkspaceInvite.
type WorkspaceInvite struct {
	Email       string `json:"email"`
	IsAdmin     bool   `json:"is_admin"`
	Operator    bool   `json:"operator"`
	WorkspaceId string `json:"workspace_id"`
}

// AccountId defines model for AccountId.
type AccountId = int

// ActionKind defines model for ActionKind.
type ActionKind string

// After defines model for After.
type After = time.Time

// ArgsFilter defines model for ArgsFilter.
type ArgsFilter = string

// Before defines model for Before.
type Before = time.Time

// ClientName defines model for ClientName.
type ClientName = string

// CreatedBy defines model for CreatedBy.
type CreatedBy = string

// IncludeHeader defines model for IncludeHeader.
type IncludeHeader = string

// InputId defines model for InputId.
type InputId = string

// JobId defines model for JobId.
type JobId = openapi_types.UUID

// JobKinds defines model for JobKinds.
type JobKinds = string

// Name defines model for Name.
type Name = string

// Operation defines model for Operation.
type Operation = string

// OrderDesc defines model for OrderDesc.
type OrderDesc = bool

// Page defines model for Page.
type Page = int

// ParentJob defines model for ParentJob.
type ParentJob = openapi_types.UUID

// Path defines model for Path.
type Path = string

// PathId defines model for PathId.
type PathId = int

// Payload defines model for Payload.
type Payload = string

// PerPage defines model for PerPage.
type PerPage = int

// QueueLimit defines model for QueueLimit.
type QueueLimit = string

// ResourceName defines model for ResourceName.
type ResourceName = string

// ResultFilter defines model for ResultFilter.
type ResultFilter = string

// RunnableId defines model for RunnableId.
type RunnableId = string

// Running defines model for Running.
type Running = bool

// ScriptExactHash defines model for ScriptExactHash.
type ScriptExactHash = string

// ScriptExactPath defines model for ScriptExactPath.
type ScriptExactPath = string

// ScriptHash defines model for ScriptHash.
type ScriptHash = string

// ScriptPath defines model for ScriptPath.
type ScriptPath = string

// ScriptStartPath defines model for ScriptStartPath.
type ScriptStartPath = string

// StartedAfter defines model for StartedAfter.
type StartedAfter = time.Time

// StartedBefore defines model for StartedBefore.
type StartedBefore = time.Time

// Success defines model for Success.
type Success = bool

// Suspended defines model for Suspended.
type Suspended = bool

// Token defines model for Token.
type Token = string

// Username defines model for Username.
type Username = string

// WorkspaceId defines model for WorkspaceId.
type WorkspaceId = string

// LoginJSONBody defines parameters for Login.
type LoginJSONBody = Login

// ConnectCallbackJSONBody defines parameters for ConnectCallback.
type ConnectCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// LoginWithOauthJSONBody defines parameters for LoginWithOauth.
type LoginWithOauthJSONBody struct {
	Code  *string `json:"code,omitempty"`
	State *string `json:"state,omitempty"`
}

// PreviewScheduleJSONBody defines parameters for PreviewSchedule.
type PreviewScheduleJSONBody struct {
	Schedule string `json:"schedule"`
	Timezone string `json:"timezone"`
}

// BashToJsonschemaJSONBody defines parameters for BashToJsonschema.
type BashToJsonschemaJSONBody = string

// DenoToJsonschemaJSONBody defines parameters for DenoToJsonschema.
type DenoToJsonschemaJSONBody = string

// GoToJsonschemaJSONBody defines parameters for GoToJsonschema.
type GoToJsonschemaJSONBody = string

// PythonToJsonschemaJSONBody defines parameters for PythonToJsonschema.
type PythonToJsonschemaJSONBody = string

// AcceptInviteJSONBody defines parameters for AcceptInvite.
type AcceptInviteJSONBody struct {
	Username    string `json:"username"`
	WorkspaceId string `json:"workspace_id"`
}

// CreateUserGloballyJSONBody defines parameters for CreateUserGlobally.
type CreateUserGloballyJSONBody struct {
	Company    *string `json:"company,omitempty"`
	Email      string  `json:"email"`
	Name       *string `json:"name,omitempty"`
	Password   string  `json:"password"`
	SuperAdmin bool    `json:"super_admin"`
}

// DeclineInviteJSONBody defines parameters for DeclineInvite.
type DeclineInviteJSONBody struct {
	WorkspaceId string `json:"workspace_id"`
}

// ListUsersAsSuperAdminParams defines parameters for ListUsersAsSuperAdmin.
type ListUsersAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetPasswordJSONBody defines parameters for SetPassword.
type SetPasswordJSONBody struct {
	Password string `json:"password"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody = NewToken

// CreateTokenImpersonateJSONBody defines parameters for CreateTokenImpersonate.
type CreateTokenImpersonateJSONBody = NewTokenImpersonate

// GlobalUserUpdateJSONBody defines parameters for GlobalUserUpdate.
type GlobalUserUpdateJSONBody struct {
	IsSuperAdmin *bool `json:"is_super_admin,omitempty"`
}

// AddGranularAclsJSONBody defines parameters for AddGranularAcls.
type AddGranularAclsJSONBody struct {
	Owner string `json:"owner"`
	Write *bool  `json:"write,omitempty"`
}

// AddGranularAclsParamsKind defines parameters for AddGranularAcls.
type AddGranularAclsParamsKind string

// GetGranularAclsParamsKind defines parameters for GetGranularAcls.
type GetGranularAclsParamsKind string

// RemoveGranularAclsJSONBody defines parameters for RemoveGranularAcls.
type RemoveGranularAclsJSONBody struct {
	Owner string `json:"owner"`
}

// RemoveGranularAclsParamsKind defines parameters for RemoveGranularAcls.
type RemoveGranularAclsParamsKind string

// CreateAppJSONBody defines parameters for CreateApp.
type CreateAppJSONBody struct {
	Path    string      `json:"path"`
	Policy  Policy      `json:"policy"`
	Summary string      `json:"summary"`
	Value   interface{} `json:"value"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	Path    *string      `json:"path,omitempty"`
	Policy  *Policy      `json:"policy,omitempty"`
	Summary *string      `json:"summary,omitempty"`
	Value   *interface{} `json:"value,omitempty"`
}

// ExecuteComponentJSONBody defines parameters for ExecuteComponent.
type ExecuteComponentJSONBody struct {
	Args                    interface{}             `json:"args"`
	ForceViewerStaticFields *map[string]interface{} `json:"force_viewer_static_fields,omitempty"`
	Path                    *string                 `json:"path,omitempty"`
	RawCode                 *struct {
		Content  string  `json:"content"`
		Language string  `json:"language"`
		Path     *string `json:"path,omitempty"`
	} `json:"raw_code,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// filter on created before (exclusive) timestamp
	Before *Before `form:"before,omitempty" json:"before,omitempty"`

	// filter on created after (exclusive) timestamp
	After *After `form:"after,omitempty" json:"after,omitempty"`

	// filter on exact username of user
	Username *Username `form:"username,omitempty" json:"username,omitempty"`

	// filter on exact or prefix name of operation
	Operation *Operation `form:"operation,omitempty" json:"operation,omitempty"`

	// filter on exact or prefix name of resource
	Resource *ResourceName `form:"resource,omitempty" json:"resource,omitempty"`

	// filter on type of operation
	ActionKind *ListAuditLogsParamsActionKind `form:"action_kind,omitempty" json:"action_kind,omitempty"`
}

// ListAuditLogsParamsActionKind defines parameters for ListAuditLogs.
type ListAuditLogsParamsActionKind string

// StarJSONBody defines parameters for Star.
type StarJSONBody struct {
	FavoriteKind *StarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                   `json:"path,omitempty"`
}

// StarJSONBodyFavoriteKind defines parameters for Star.
type StarJSONBodyFavoriteKind string

// UnstarJSONBody defines parameters for Unstar.
type UnstarJSONBody struct {
	FavoriteKind *UnstarJSONBodyFavoriteKind `json:"favorite_kind,omitempty"`
	Path         *string                     `json:"path,omitempty"`
}

// UnstarJSONBodyFavoriteKind defines parameters for Unstar.
type UnstarJSONBodyFavoriteKind string

// ArchiveFlowByPathJSONBody defines parameters for ArchiveFlowByPath.
type ArchiveFlowByPathJSONBody struct {
	Archived *bool `json:"archived,omitempty"`
}

// CreateFlowJSONBody defines parameters for CreateFlow.
type CreateFlowJSONBody = OpenFlowWPath

// GetFlowInputHistoryByPathParams defines parameters for GetFlowInputHistoryByPath.
type GetFlowInputHistoryByPathParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListFlowsParams defines parameters for ListFlows.
type ListFlowsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are displayed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// UpdateFlowJSONBody defines parameters for UpdateFlow.
type UpdateFlowJSONBody = OpenFlowWPath

// AddOwnerToFolderJSONBody defines parameters for AddOwnerToFolder.
type AddOwnerToFolderJSONBody struct {
	Owner *string `json:"owner,omitempty"`
}

// CreateFolderJSONBody defines parameters for CreateFolder.
type CreateFolderJSONBody struct {
	ExtraPerms *CreateFolderJSONBody_ExtraPerms `json:"extra_perms,omitempty"`
	Name       string                           `json:"name"`
	Owners     *[]string                        `json:"owners,omitempty"`
}

// CreateFolderJSONBody_ExtraPerms defines parameters for CreateFolder.
type CreateFolderJSONBody_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListFolderNamesParams defines parameters for ListFolderNames.
type ListFolderNamesParams struct {
	// only list the folders the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveOwnerToFolderJSONBody defines parameters for RemoveOwnerToFolder.
type RemoveOwnerToFolderJSONBody struct {
	Owner *string `json:"owner,omitempty"`
}

// UpdateFolderJSONBody defines parameters for UpdateFolder.
type UpdateFolderJSONBody struct {
	ExtraPerms *UpdateFolderJSONBody_ExtraPerms `json:"extra_perms,omitempty"`
	Owners     *[]string                        `json:"owners,omitempty"`
}

// UpdateFolderJSONBody_ExtraPerms defines parameters for UpdateFolder.
type UpdateFolderJSONBody_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// AddUserToGroupJSONBody defines parameters for AddUserToGroup.
type AddUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name    string  `json:"name"`
	Summary *string `json:"summary,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListGroupNamesParams defines parameters for ListGroupNames.
type ListGroupNamesParams struct {
	// only list the groups the user is member of (default false)
	OnlyMemberOf *bool `form:"only_member_of,omitempty" json:"only_member_of,omitempty"`
}

// RemoveUserToGroupJSONBody defines parameters for RemoveUserToGroup.
type RemoveUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Summary *string `json:"summary,omitempty"`
}

// CreateInputJSONBody defines parameters for CreateInput.
type CreateInputJSONBody = CreateInput

// CreateInputParams defines parameters for CreateInput.
type CreateInputParams struct {
	RunnableId   *RunnableId   `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableType `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`
}

// GetInputHistoryParams defines parameters for GetInputHistory.
type GetInputHistoryParams struct {
	RunnableId   *RunnableId   `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableType `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListInputsParams defines parameters for ListInputs.
type ListInputsParams struct {
	RunnableId   *RunnableId   `form:"runnable_id,omitempty" json:"runnable_id,omitempty"`
	RunnableType *RunnableType `form:"runnable_type,omitempty" json:"runnable_type,omitempty"`

	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// UpdateInputJSONBody defines parameters for UpdateInput.
type UpdateInputJSONBody = UpdateInput

// ListCompletedJobsParams defines parameters for ListCompletedJobs.
type ListCompletedJobsParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on created after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`
}

// ResumeSuspendedFlowAsOwnerJSONBody defines parameters for ResumeSuspendedFlowAsOwner.
type ResumeSuspendedFlowAsOwnerJSONBody = map[string]interface{}

// CreateJobSignatureParams defines parameters for CreateJobSignature.
type CreateJobSignatureParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on created after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`
}

// ListQueueParams defines parameters for ListQueue.
type ListQueueParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	StartedBefore *StartedBefore `form:"started_before,omitempty" json:"started_before,omitempty"`

	// filter on created after (exclusive) timestamp
	StartedAfter *StartedAfter `form:"started_after,omitempty" json:"started_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// filter on suspended jobs
	Suspended *Suspended `form:"suspended,omitempty" json:"suspended,omitempty"`

	// filter on running jobs
	Running *Running `form:"running,omitempty" json:"running,omitempty"`

	// filter on jobs containing those args as a json subset (@> in postgres)
	Args *ArgsFilter `form:"args,omitempty" json:"args,omitempty"`

	// filter on jobs containing those result as a json subset (@> in postgres)
	Result *ResultFilter `form:"result,omitempty" json:"result,omitempty"`
}

// GetResumeUrlsParams defines parameters for GetResumeUrls.
type GetResumeUrlsParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// RunFlowByPathJSONBody defines parameters for RunFlowByPath.
type RunFlowByPathJSONBody = ScriptArgs

// RunFlowByPathParams defines parameters for RunFlowByPath.
type RunFlowByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the flow owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptByHashJSONBody defines parameters for RunScriptByHash.
type RunScriptByHashJSONBody = map[string]interface{}

// RunScriptByHashParams defines parameters for RunScriptByHash.
type RunScriptByHashParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptByPathJSONBody defines parameters for RunScriptByPath.
type RunScriptByPathJSONBody = ScriptArgs

// RunScriptByPathParams defines parameters for RunScriptByPath.
type RunScriptByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunScriptPreviewJSONBody defines parameters for RunScriptPreview.
type RunScriptPreviewJSONBody = Preview

// RunScriptPreviewParams defines parameters for RunScriptPreview.
type RunScriptPreviewParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunFlowPreviewJSONBody defines parameters for RunFlowPreview.
type RunFlowPreviewJSONBody = FlowPreview

// RunFlowPreviewParams defines parameters for RunFlowPreview.
type RunFlowPreviewParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// make the run invisible to the the script owner (default false)
	InvisibleToOwner *bool `form:"invisible_to_owner,omitempty" json:"invisible_to_owner,omitempty"`
}

// RunWaitResultFlowByPathJSONBody defines parameters for RunWaitResultFlowByPath.
type RunWaitResultFlowByPathJSONBody = ScriptArgs

// RunWaitResultFlowByPathParams defines parameters for RunWaitResultFlowByPath.
type RunWaitResultFlowByPathParams struct {
	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`
}

// RunWaitResultScriptByPathGetParams defines parameters for RunWaitResultScriptByPathGet.
type RunWaitResultScriptByPathGetParams struct {
	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`

	// The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload *Payload `form:"payload,omitempty" json:"payload,omitempty"`
}

// RunWaitResultScriptByPathJSONBody defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathJSONBody = ScriptArgs

// RunWaitResultScriptByPathParams defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathParams struct {
	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// List of headers's keys (separated with ',') whove value are added to the args
	// Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
	IncludeHeader *IncludeHeader `form:"include_header,omitempty" json:"include_header,omitempty"`

	// The maximum size of the queue for which the request would get rejected if that job would push it above that limit
	QueueLimit *QueueLimit `form:"queue_limit,omitempty" json:"queue_limit,omitempty"`
}

// CancelSuspendedJobGetParams defines parameters for CancelSuspendedJobGet.
type CancelSuspendedJobGetParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// CancelSuspendedJobPostJSONBody defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostJSONBody = map[string]interface{}

// CancelSuspendedJobPostParams defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetSuspendedJobFlowParams defines parameters for GetSuspendedJobFlow.
type GetSuspendedJobFlowParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// GetJobUpdatesParams defines parameters for GetJobUpdates.
type GetJobUpdatesParams struct {
	Running   *bool `form:"running,omitempty" json:"running,omitempty"`
	LogOffset *int  `form:"log_offset,omitempty" json:"log_offset,omitempty"`
}

// CancelQueuedJobJSONBody defines parameters for CancelQueuedJob.
type CancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ForceCancelQueuedJobJSONBody defines parameters for ForceCancelQueuedJob.
type ForceCancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ResumeSuspendedJobGetParams defines parameters for ResumeSuspendedJobGet.
type ResumeSuspendedJobGetParams struct {
	// The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
	// `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
	Payload  *Payload `form:"payload,omitempty" json:"payload,omitempty"`
	Approver *string  `form:"approver,omitempty" json:"approver,omitempty"`
}

// ResumeSuspendedJobPostJSONBody defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostJSONBody = map[string]interface{}

// ResumeSuspendedJobPostParams defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostParams struct {
	Approver *string `form:"approver,omitempty" json:"approver,omitempty"`
}

// ConnectSlackCallbackJSONBody defines parameters for ConnectSlackCallback.
type ConnectSlackCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody struct {
	Client       string  `json:"client"`
	ExpiresIn    int     `json:"expires_in"`
	Owner        string  `json:"owner"`
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	Path string `json:"path"`
}

// CreateResourceJSONBody defines parameters for CreateResource.
type CreateResourceJSONBody = CreateResource

// ListResourceParams defines parameters for ListResource.
type ListResourceParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// resource_types to list from, separated by ',',
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// resource_types to not list from, separated by ',',
	ResourceTypeExclude *string `form:"resource_type_exclude,omitempty" json:"resource_type_exclude,omitempty"`
}

// CreateResourceTypeJSONBody defines parameters for CreateResourceType.
type CreateResourceTypeJSONBody = ResourceType

// UpdateResourceTypeJSONBody defines parameters for UpdateResourceType.
type UpdateResourceTypeJSONBody = EditResourceType

// UpdateResourceJSONBody defines parameters for UpdateResource.
type UpdateResourceJSONBody = EditResource

// UpdateResourceValueJSONBody defines parameters for UpdateResourceValue.
type UpdateResourceValueJSONBody struct {
	Value *interface{} `json:"value,omitempty"`
}

// CreateScheduleJSONBody defines parameters for CreateSchedule.
type CreateScheduleJSONBody = NewSchedule

// ListSchedulesParams defines parameters for ListSchedules.
type ListSchedulesParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetScheduleEnabledJSONBody defines parameters for SetScheduleEnabled.
type SetScheduleEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// UpdateScheduleJSONBody defines parameters for UpdateSchedule.
type UpdateScheduleJSONBody = EditSchedule

// CreateScriptJSONBody defines parameters for CreateScript.
type CreateScriptJSONBody struct {
	Content     string                       `json:"content"`
	Description string                       `json:"description"`
	IsTemplate  *bool                        `json:"is_template,omitempty"`
	Kind        *CreateScriptJSONBodyKind    `json:"kind,omitempty"`
	Language    CreateScriptJSONBodyLanguage `json:"language"`
	Lock        *[]string                    `json:"lock,omitempty"`
	ParentHash  *string                      `json:"parent_hash,omitempty"`
	Path        string                       `json:"path"`
	Schema      *map[string]interface{}      `json:"schema,omitempty"`
	Summary     string                       `json:"summary"`
}

// CreateScriptJSONBodyKind defines parameters for CreateScript.
type CreateScriptJSONBodyKind string

// CreateScriptJSONBodyLanguage defines parameters for CreateScript.
type CreateScriptJSONBodyLanguage string

// ListScriptsParams defines parameters for ListScripts.
type ListScriptsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// mask to filter scripts whom first direct parent has exact hash
	FirstParentHash *string `form:"first_parent_hash,omitempty" json:"first_parent_hash,omitempty"`

	// mask to filter scripts whom last parent in the chain has exact hash.
	// Beware that each script stores only a limited number of parents. Hence
	// the last parent hash for a script is not necessarily its top-most parent.
	// To find the top-most parent you will have to jump from last to last hash
	//  until finding the parent
	LastParentHash *string `form:"last_parent_hash,omitempty" json:"last_parent_hash,omitempty"`

	// is the hash present in the array of stored parent hashes for this script.
	// The same warning applies than for last_parent_hash. A script only store a
	// limited number of direct parent
	ParentHash *string `form:"parent_hash,omitempty" json:"parent_hash,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are
	// ed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// (default regardless)
	// if true show only the templates
	// if false show only the non templates
	// if not defined, show all regardless of if the script is a template
	IsTemplate *bool `form:"is_template,omitempty" json:"is_template,omitempty"`

	// (default regardless)
	// script kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`

	// (default false)
	// show only the starred items
	StarredOnly *bool `form:"starred_only,omitempty" json:"starred_only,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody = NewUser

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody = EditWorkspaceUser

// CreateVariableJSONBody defines parameters for CreateVariable.
type CreateVariableJSONBody = CreateVariable

// CreateVariableParams defines parameters for CreateVariable.
type CreateVariableParams struct {
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// GetVariableParams defines parameters for GetVariable.
type GetVariableParams struct {
	// ask to decrypt secret if this variable is secret
	// (if not secret no effect, default: true)
	DecryptSecret *bool `form:"decrypt_secret,omitempty" json:"decrypt_secret,omitempty"`
}

// UpdateVariableJSONBody defines parameters for UpdateVariable.
type UpdateVariableJSONBody = EditVariable

// UpdateVariableParams defines parameters for UpdateVariable.
type UpdateVariableParams struct {
	AlreadyEncrypted *bool `form:"already_encrypted,omitempty" json:"already_encrypted,omitempty"`
}

// AddUserJSONBody defines parameters for AddUser.
type AddUserJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
	Username string `json:"username"`
}

// DeleteInviteJSONBody defines parameters for DeleteInvite.
type DeleteInviteJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
}

// EditAutoInviteJSONBody defines parameters for EditAutoInvite.
type EditAutoInviteJSONBody struct {
	Operator *bool `json:"operator,omitempty"`
}

// EditSlackCommandJSONBody defines parameters for EditSlackCommand.
type EditSlackCommandJSONBody struct {
	SlackCommandScript *string `json:"slack_command_script,omitempty"`
}

// EditWebhookJSONBody defines parameters for EditWebhook.
type EditWebhookJSONBody struct {
	Webhook *string `json:"webhook,omitempty"`
}

// InviteUserJSONBody defines parameters for InviteUser.
type InviteUserJSONBody struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Operator bool   `json:"operator"`
}

// ListWorkersParams defines parameters for ListWorkers.
type ListWorkersParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateWorkspaceJSONBody defines parameters for CreateWorkspace.
type CreateWorkspaceJSONBody = CreateWorkspace

// ExistsWorkspaceJSONBody defines parameters for ExistsWorkspace.
type ExistsWorkspaceJSONBody struct {
	Id string `json:"id"`
}

// ExistsUsernameJSONBody defines parameters for ExistsUsername.
type ExistsUsernameJSONBody struct {
	Id       string `json:"id"`
	Username string `json:"username"`
}

// ListWorkspacesAsSuperAdminParams defines parameters for ListWorkspacesAsSuperAdmin.
type ListWorkspacesAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginJSONBody

// ConnectCallbackJSONRequestBody defines body for ConnectCallback for application/json ContentType.
type ConnectCallbackJSONRequestBody ConnectCallbackJSONBody

// LoginWithOauthJSONRequestBody defines body for LoginWithOauth for application/json ContentType.
type LoginWithOauthJSONRequestBody LoginWithOauthJSONBody

// PreviewScheduleJSONRequestBody defines body for PreviewSchedule for application/json ContentType.
type PreviewScheduleJSONRequestBody PreviewScheduleJSONBody

// BashToJsonschemaJSONRequestBody defines body for BashToJsonschema for application/json ContentType.
type BashToJsonschemaJSONRequestBody = BashToJsonschemaJSONBody

// DenoToJsonschemaJSONRequestBody defines body for DenoToJsonschema for application/json ContentType.
type DenoToJsonschemaJSONRequestBody = DenoToJsonschemaJSONBody

// GoToJsonschemaJSONRequestBody defines body for GoToJsonschema for application/json ContentType.
type GoToJsonschemaJSONRequestBody = GoToJsonschemaJSONBody

// PythonToJsonschemaJSONRequestBody defines body for PythonToJsonschema for application/json ContentType.
type PythonToJsonschemaJSONRequestBody = PythonToJsonschemaJSONBody

// AcceptInviteJSONRequestBody defines body for AcceptInvite for application/json ContentType.
type AcceptInviteJSONRequestBody AcceptInviteJSONBody

// CreateUserGloballyJSONRequestBody defines body for CreateUserGlobally for application/json ContentType.
type CreateUserGloballyJSONRequestBody CreateUserGloballyJSONBody

// DeclineInviteJSONRequestBody defines body for DeclineInvite for application/json ContentType.
type DeclineInviteJSONRequestBody DeclineInviteJSONBody

// SetPasswordJSONRequestBody defines body for SetPassword for application/json ContentType.
type SetPasswordJSONRequestBody SetPasswordJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = CreateTokenJSONBody

// CreateTokenImpersonateJSONRequestBody defines body for CreateTokenImpersonate for application/json ContentType.
type CreateTokenImpersonateJSONRequestBody = CreateTokenImpersonateJSONBody

// GlobalUserUpdateJSONRequestBody defines body for GlobalUserUpdate for application/json ContentType.
type GlobalUserUpdateJSONRequestBody GlobalUserUpdateJSONBody

// AddGranularAclsJSONRequestBody defines body for AddGranularAcls for application/json ContentType.
type AddGranularAclsJSONRequestBody AddGranularAclsJSONBody

// RemoveGranularAclsJSONRequestBody defines body for RemoveGranularAcls for application/json ContentType.
type RemoveGranularAclsJSONRequestBody RemoveGranularAclsJSONBody

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody CreateAppJSONBody

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// ExecuteComponentJSONRequestBody defines body for ExecuteComponent for application/json ContentType.
type ExecuteComponentJSONRequestBody ExecuteComponentJSONBody

// StarJSONRequestBody defines body for Star for application/json ContentType.
type StarJSONRequestBody StarJSONBody

// UnstarJSONRequestBody defines body for Unstar for application/json ContentType.
type UnstarJSONRequestBody UnstarJSONBody

// ArchiveFlowByPathJSONRequestBody defines body for ArchiveFlowByPath for application/json ContentType.
type ArchiveFlowByPathJSONRequestBody ArchiveFlowByPathJSONBody

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody = CreateFlowJSONBody

// UpdateFlowJSONRequestBody defines body for UpdateFlow for application/json ContentType.
type UpdateFlowJSONRequestBody = UpdateFlowJSONBody

// AddOwnerToFolderJSONRequestBody defines body for AddOwnerToFolder for application/json ContentType.
type AddOwnerToFolderJSONRequestBody AddOwnerToFolderJSONBody

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody CreateFolderJSONBody

// RemoveOwnerToFolderJSONRequestBody defines body for RemoveOwnerToFolder for application/json ContentType.
type RemoveOwnerToFolderJSONRequestBody RemoveOwnerToFolderJSONBody

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody UpdateFolderJSONBody

// AddUserToGroupJSONRequestBody defines body for AddUserToGroup for application/json ContentType.
type AddUserToGroupJSONRequestBody AddUserToGroupJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// RemoveUserToGroupJSONRequestBody defines body for RemoveUserToGroup for application/json ContentType.
type RemoveUserToGroupJSONRequestBody RemoveUserToGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// CreateInputJSONRequestBody defines body for CreateInput for application/json ContentType.
type CreateInputJSONRequestBody = CreateInputJSONBody

// UpdateInputJSONRequestBody defines body for UpdateInput for application/json ContentType.
type UpdateInputJSONRequestBody = UpdateInputJSONBody

// ResumeSuspendedFlowAsOwnerJSONRequestBody defines body for ResumeSuspendedFlowAsOwner for application/json ContentType.
type ResumeSuspendedFlowAsOwnerJSONRequestBody = ResumeSuspendedFlowAsOwnerJSONBody

// RunFlowByPathJSONRequestBody defines body for RunFlowByPath for application/json ContentType.
type RunFlowByPathJSONRequestBody = RunFlowByPathJSONBody

// RunScriptByHashJSONRequestBody defines body for RunScriptByHash for application/json ContentType.
type RunScriptByHashJSONRequestBody = RunScriptByHashJSONBody

// RunScriptByPathJSONRequestBody defines body for RunScriptByPath for application/json ContentType.
type RunScriptByPathJSONRequestBody = RunScriptByPathJSONBody

// RunScriptPreviewJSONRequestBody defines body for RunScriptPreview for application/json ContentType.
type RunScriptPreviewJSONRequestBody = RunScriptPreviewJSONBody

// RunFlowPreviewJSONRequestBody defines body for RunFlowPreview for application/json ContentType.
type RunFlowPreviewJSONRequestBody = RunFlowPreviewJSONBody

// RunWaitResultFlowByPathJSONRequestBody defines body for RunWaitResultFlowByPath for application/json ContentType.
type RunWaitResultFlowByPathJSONRequestBody = RunWaitResultFlowByPathJSONBody

// RunWaitResultScriptByPathJSONRequestBody defines body for RunWaitResultScriptByPath for application/json ContentType.
type RunWaitResultScriptByPathJSONRequestBody = RunWaitResultScriptByPathJSONBody

// CancelSuspendedJobPostJSONRequestBody defines body for CancelSuspendedJobPost for application/json ContentType.
type CancelSuspendedJobPostJSONRequestBody = CancelSuspendedJobPostJSONBody

// CancelQueuedJobJSONRequestBody defines body for CancelQueuedJob for application/json ContentType.
type CancelQueuedJobJSONRequestBody CancelQueuedJobJSONBody

// ForceCancelQueuedJobJSONRequestBody defines body for ForceCancelQueuedJob for application/json ContentType.
type ForceCancelQueuedJobJSONRequestBody ForceCancelQueuedJobJSONBody

// ResumeSuspendedJobPostJSONRequestBody defines body for ResumeSuspendedJobPost for application/json ContentType.
type ResumeSuspendedJobPostJSONRequestBody = ResumeSuspendedJobPostJSONBody

// ConnectSlackCallbackJSONRequestBody defines body for ConnectSlackCallback for application/json ContentType.
type ConnectSlackCallbackJSONRequestBody ConnectSlackCallbackJSONBody

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody CreateAccountJSONBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody = CreateResourceJSONBody

// CreateResourceTypeJSONRequestBody defines body for CreateResourceType for application/json ContentType.
type CreateResourceTypeJSONRequestBody = CreateResourceTypeJSONBody

// UpdateResourceTypeJSONRequestBody defines body for UpdateResourceType for application/json ContentType.
type UpdateResourceTypeJSONRequestBody = UpdateResourceTypeJSONBody

// UpdateResourceJSONRequestBody defines body for UpdateResource for application/json ContentType.
type UpdateResourceJSONRequestBody = UpdateResourceJSONBody

// UpdateResourceValueJSONRequestBody defines body for UpdateResourceValue for application/json ContentType.
type UpdateResourceValueJSONRequestBody UpdateResourceValueJSONBody

// CreateScheduleJSONRequestBody defines body for CreateSchedule for application/json ContentType.
type CreateScheduleJSONRequestBody = CreateScheduleJSONBody

// SetScheduleEnabledJSONRequestBody defines body for SetScheduleEnabled for application/json ContentType.
type SetScheduleEnabledJSONRequestBody SetScheduleEnabledJSONBody

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = UpdateScheduleJSONBody

// CreateScriptJSONRequestBody defines body for CreateScript for application/json ContentType.
type CreateScriptJSONRequestBody CreateScriptJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserJSONBody

// CreateVariableJSONRequestBody defines body for CreateVariable for application/json ContentType.
type CreateVariableJSONRequestBody = CreateVariableJSONBody

// UpdateVariableJSONRequestBody defines body for UpdateVariable for application/json ContentType.
type UpdateVariableJSONRequestBody = UpdateVariableJSONBody

// AddUserJSONRequestBody defines body for AddUser for application/json ContentType.
type AddUserJSONRequestBody AddUserJSONBody

// DeleteInviteJSONRequestBody defines body for DeleteInvite for application/json ContentType.
type DeleteInviteJSONRequestBody DeleteInviteJSONBody

// EditAutoInviteJSONRequestBody defines body for EditAutoInvite for application/json ContentType.
type EditAutoInviteJSONRequestBody EditAutoInviteJSONBody

// EditSlackCommandJSONRequestBody defines body for EditSlackCommand for application/json ContentType.
type EditSlackCommandJSONRequestBody EditSlackCommandJSONBody

// EditWebhookJSONRequestBody defines body for EditWebhook for application/json ContentType.
type EditWebhookJSONRequestBody EditWebhookJSONBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody InviteUserJSONBody

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspaceJSONBody

// ExistsWorkspaceJSONRequestBody defines body for ExistsWorkspace for application/json ContentType.
type ExistsWorkspaceJSONRequestBody ExistsWorkspaceJSONBody

// ExistsUsernameJSONRequestBody defines body for ExistsUsername for application/json ContentType.
type ExistsUsernameJSONRequestBody ExistsUsernameJSONBody

// Getter for additional properties for CreateFolderJSONBody_ExtraPerms. Returns the specified
// element and whether it was found
func (a CreateFolderJSONBody_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateFolderJSONBody_ExtraPerms
func (a *CreateFolderJSONBody_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a *CreateFolderJSONBody_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a CreateFolderJSONBody_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateFolderJSONBody_ExtraPerms. Returns the specified
// element and whether it was found
func (a UpdateFolderJSONBody_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateFolderJSONBody_ExtraPerms
func (a *UpdateFolderJSONBody_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a *UpdateFolderJSONBody_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateFolderJSONBody_ExtraPerms to handle AdditionalProperties
func (a UpdateFolderJSONBody_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AppWithLastVersion_ExtraPerms. Returns the specified
// element and whether it was found
func (a AppWithLastVersion_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppWithLastVersion_ExtraPerms
func (a *AppWithLastVersion_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppWithLastVersion_ExtraPerms to handle AdditionalProperties
func (a *AppWithLastVersion_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppWithLastVersion_ExtraPerms to handle AdditionalProperties
func (a AppWithLastVersion_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Folder_ExtraPerms. Returns the specified
// element and whether it was found
func (a Folder_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Folder_ExtraPerms
func (a *Folder_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Folder_ExtraPerms to handle AdditionalProperties
func (a *Folder_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Folder_ExtraPerms to handle AdditionalProperties
func (a Folder_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Group_ExtraPerms. Returns the specified
// element and whether it was found
func (a Group_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Group_ExtraPerms
func (a *Group_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a *Group_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a Group_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableApp_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableApp_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableApp_ExtraPerms
func (a *ListableApp_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableApp_ExtraPerms to handle AdditionalProperties
func (a *ListableApp_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableApp_ExtraPerms to handle AdditionalProperties
func (a ListableApp_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableResource_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableResource_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableResource_ExtraPerms
func (a *ListableResource_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableResource_ExtraPerms to handle AdditionalProperties
func (a *ListableResource_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableResource_ExtraPerms to handle AdditionalProperties
func (a ListableResource_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableVariable_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableVariable_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableVariable_ExtraPerms
func (a *ListableVariable_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a *ListableVariable_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a ListableVariable_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PathFlow_InputTransforms. Returns the specified
// element and whether it was found
func (a PathFlow_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PathFlow_InputTransforms
func (a *PathFlow_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PathFlow_InputTransforms to handle AdditionalProperties
func (a *PathFlow_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PathFlow_InputTransforms to handle AdditionalProperties
func (a PathFlow_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PathScript_InputTransforms. Returns the specified
// element and whether it was found
func (a PathScript_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PathScript_InputTransforms
func (a *PathScript_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PathScript_InputTransforms to handle AdditionalProperties
func (a *PathScript_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PathScript_InputTransforms to handle AdditionalProperties
func (a PathScript_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Policy_Triggerables. Returns the specified
// element and whether it was found
func (a Policy_Triggerables) Get(fieldName string) (value map[string]interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Policy_Triggerables
func (a *Policy_Triggerables) Set(fieldName string, value map[string]interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Policy_Triggerables to handle AdditionalProperties
func (a *Policy_Triggerables) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal map[string]interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Policy_Triggerables to handle AdditionalProperties
func (a Policy_Triggerables) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RawScript_InputTransforms. Returns the specified
// element and whether it was found
func (a RawScript_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RawScript_InputTransforms
func (a *RawScript_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RawScript_InputTransforms to handle AdditionalProperties
func (a *RawScript_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RawScript_InputTransforms to handle AdditionalProperties
func (a RawScript_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Resource_ExtraPerms. Returns the specified
// element and whether it was found
func (a Resource_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Resource_ExtraPerms
func (a *Resource_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a *Resource_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a Resource_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Schedule_ExtraPerms. Returns the specified
// element and whether it was found
func (a Schedule_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Schedule_ExtraPerms
func (a *Schedule_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a *Schedule_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a Schedule_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Script_ExtraPerms. Returns the specified
// element and whether it was found
func (a Script_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Script_ExtraPerms
func (a *Script_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a *Script_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a Script_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScriptArgs. Returns the specified
// element and whether it was found
func (a ScriptArgs) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScriptArgs
func (a *ScriptArgs) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a *ScriptArgs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a ScriptArgs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetHubAppById request
	GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubApps request
	ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubFlowById request
	GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubFlows request
	ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectCallback request with any body
	ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthConnects request
	ListOAuthConnects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOAuthLogins request
	ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithOauth request with any body
	LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenApiYaml request
	GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewSchedule request with any body
	PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BashToJsonschema request with any body
	BashToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BashToJsonschema(ctx context.Context, body BashToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DenoToJsonschema request with any body
	DenoToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DenoToJsonschema(ctx context.Context, body DenoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GoToJsonschema request with any body
	GoToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GoToJsonschema(ctx context.Context, body GoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptContentByPath request
	GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubScriptByPath request
	GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHubScripts request
	ListHubScripts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PythonToJsonschema request with any body
	PythonToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PythonToJsonschema(ctx context.Context, body PythonToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPathTokened request
	RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptInvite request with any body
	AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserGlobally request with any body
	CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeclineInvite request with any body
	DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserDelete request
	GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentEmail request
	GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersAsSuperAdmin request
	ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceInvites request
	ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPassword request with any body
	SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenImpersonate request with any body
	CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalUserUpdate request with any body
	GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsage request
	GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalWhoami request
	GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackendVersion request
	BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGranularAcls request with any body
	AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGranularAcls request
	GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveGranularAcls request with any body
	RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApp request with any body
	CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsApp request
	ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByPath request
	GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByVersion request
	GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicSecretOfApp request
	GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApp request with any body
	UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteComponent request with any body
	ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPublicAppBySecret request
	GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuditLog request
	GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCapture request
	GetCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCapture request
	CreateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCapture request
	UpdateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Star request with any body
	StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Unstar request with any body
	UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveFlowByPath request with any body
	ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlow request with any body
	CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlowByPath request
	DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsFlowByPath request
	ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowByPath request
	GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowInputHistoryByPath request
	GetFlowInputHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlows request
	ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowPaths request
	ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlow request with any body
	UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOwnerToFolder request with any body
	AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolder request with any body
	CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolder request
	GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolderUsage request
	GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolders request
	ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolderNames request
	ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveOwnerToFolder request with any body
	RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFolder request with any body
	UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroup request with any body
	AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request with any body
	CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupNames request
	ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserToGroup request with any body
	RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroup request with any body
	UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInput request with any body
	CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInput request
	DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInputHistory request
	GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInputs request
	ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInput request with any body
	UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCompletedJob request
	DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJob request
	GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompletedJobResult request
	GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCompletedJobs request
	ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedFlowAsOwner request with any body
	ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobSignature request
	CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQueue request
	ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResultById request
	ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResumeUrls request
	GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowByPath request with any body
	RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByHash request with any body
	RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptByPath request with any body
	RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunScriptPreview request with any body
	RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFlowPreview request with any body
	RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultFlowByPath request with any body
	RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPathGet request
	RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunWaitResultScriptByPath request with any body
	RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobGet request
	CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelSuspendedJobPost request with any body
	CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSuspendedJobFlow request
	GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobUpdates request
	GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelQueuedJob request with any body
	CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForceCancelQueuedJob request with any body
	ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobGet request
	ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSuspendedJobPost request with any body
	ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectSlackCallback request with any body
	ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccount request with any body
	CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectAccount request
	DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisconnectSlack request
	DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshToken request with any body
	RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResource request with any body
	CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResource(ctx context.Context, workspace WorkspaceId, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResource request
	DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResource request
	ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceValue request
	GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResource request
	ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceType request with any body
	CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResourceType request
	DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsResourceType request
	ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourceType request
	GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceType request
	ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListResourceTypeNames request
	ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceType request with any body
	UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResource request with any body
	UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateResourceValue request with any body
	UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchedule request with any body
	CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchedule request
	DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsSchedule request
	ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedule request
	GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedules request
	ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetScheduleEnabled request with any body
	SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByHash request
	ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveScriptByPath request
	ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScript request with any body
	CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByHash request
	DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScriptByPath request
	DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptDeploymentStatus request
	GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsScriptByPath request
	ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByHash request
	GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScriptByPath request
	GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScripts request
	ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScriptPaths request
	ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByHash request
	RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawScriptByPath request
	RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsOwnerOfPath request
	IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveWorkspace request
	LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsernames request
	ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Whois request
	Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVariable request with any body
	CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVariable request
	DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsVariable request
	ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVariable request
	GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVariable request
	ListVariable(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContextualVariables request
	ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVariable request with any body
	UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUser request with any body
	AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkspace request
	ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvite request with any body
	DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAutoInvite request with any body
	EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditSlackCommand request with any body
	EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditWebhook request with any body
	EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUser request with any body
	InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPendingInvites request
	ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPremiumInfo request
	GetPremiumInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkers request
	ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsDomainAllowed request
	IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsWorkspace request with any body
	ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExistsUsername request with any body
	ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaces request
	ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspacesAsSuperAdmin request
	ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkspace request
	UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserWorkspaces request
	ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetHubAppById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubAppByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubFlowById(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubFlowByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubFlows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubFlowsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallbackWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectCallback(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectCallbackRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthConnects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthConnectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOAuthLogins(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOAuthLoginsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauthWithBody(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequestWithBody(c.Server, clientName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithOauth(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginWithOauthRequest(c.Server, clientName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenApiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenApiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewSchedule(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewScheduleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BashToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBashToJsonschemaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BashToJsonschema(ctx context.Context, body BashToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBashToJsonschemaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenoToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenoToJsonschemaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenoToJsonschema(ctx context.Context, body DenoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenoToJsonschemaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoToJsonschemaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoToJsonschema(ctx context.Context, body GoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoToJsonschemaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptContentByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptContentByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubScriptByPath(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubScriptByPathRequest(c.Server, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHubScripts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHubScriptsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PythonToJsonschemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPythonToJsonschemaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PythonToJsonschema(ctx context.Context, body PythonToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPythonToJsonschemaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPathTokened(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathTokenedRequest(c.Server, workspace, token, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvite(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGloballyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserGlobally(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserGloballyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeclineInvite(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeclineInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserDelete(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserDeleteRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentEmail(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentEmailRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersAsSuperAdmin(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceInvites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceInvitesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPassword(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, tokenPrefix)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenImpersonate(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenImpersonateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdateWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequestWithBody(c.Server, email, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalUserUpdate(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalUserUpdateRequest(c.Server, email, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalWhoami(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackendVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackendVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGranularAcls(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGranularAcls(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGranularAclsRequest(c.Server, workspace, kind, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAclsWithBody(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequestWithBody(c.Server, workspace, kind, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveGranularAcls(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveGranularAclsRequest(c.Server, workspace, kind, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByVersion(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByVersionRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicSecretOfApp(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicSecretOfAppRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponentWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteComponent(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteComponentRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPublicAppBySecret(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPublicAppBySecretRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuditLog(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuditLogRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCapture(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaptureRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Star(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnstarWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Unstar(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnstarRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFlowByPathRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlowWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlow(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowInputHistoryByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowInputHistoryByPathRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlows(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlow(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolder(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolder(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolderUsage(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderUsageRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolders(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFoldersRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolderNames(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFolderNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveOwnerToFolder(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveOwnerToFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolder(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, workspace, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupNames(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupNamesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserToGroup(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserToGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, workspace, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, workspace, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInputWithBody(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInput(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInputRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInput(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInputRequest(c.Server, workspace, input)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInputHistory(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInputHistoryRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInputs(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInputsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInputWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInput(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInputRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompletedJobResult(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompletedJobResultRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCompletedJobs(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCompletedJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwnerWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedFlowAsOwner(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedFlowAsOwnerRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobSignature(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobSignatureRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQueue(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQueueRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResultById(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResultByIdRequest(c.Server, workspace, flowJobId, nodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResumeUrls(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResumeUrlsRequest(c.Server, workspace, id, resumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHashWithBody(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequestWithBody(c.Server, workspace, hash, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByHashRequest(c.Server, workspace, hash, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunScriptPreview(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunScriptPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreviewWithBody(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFlowPreview(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFlowPreviewRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultFlowByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultFlowByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathGet(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathGetRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPathWithBody(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunWaitResultScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunWaitResultScriptByPathRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSuspendedJobFlow(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSuspendedJobFlowRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobUpdates(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobUpdatesRequest(c.Server, workspace, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJobWithBody(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForceCancelQueuedJob(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForceCancelQueuedJobRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobGet(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobGetRequest(c.Server, workspace, id, resumeId, signature, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPostWithBody(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequestWithBody(c.Server, workspace, id, resumeId, signature, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSuspendedJobPost(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSuspendedJobPostRequest(c.Server, workspace, id, resumeId, signature, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallbackWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectSlackCallback(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectSlackCallbackRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectAccount(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectAccountRequest(c.Server, workspace, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisconnectSlack(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisconnectSlackRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, workspace, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, workspace, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResource(ctx context.Context, workspace WorkspaceId, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceValue(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceValueRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResource(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceType(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceTypeRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourceType(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceTypeRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceType(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListResourceTypeNames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListResourceTypeNamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceTypeWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceType(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceTypeRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResource(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValueWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateResourceValue(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateResourceValueRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScheduleWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchedule(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScheduleRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedule(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedules(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabledWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEnabled(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEnabledRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduleWithBody(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequestWithBody(c.Server, workspace, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchedule(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequest(c.Server, workspace, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScriptWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScript(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScriptRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptDeploymentStatus(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptDeploymentStatusRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByHash(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByHashRequest(c.Server, workspace, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScripts(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptsRequest(c.Server, workspace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScriptPaths(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScriptPathsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByHash(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByHashRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawScriptByPath(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawScriptByPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsOwnerOfPath(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsOwnerOfPathRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LeaveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsernames(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsernamesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, workspace, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, workspace, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Whois(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWhoisRequest(c.Server, workspace, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariableWithBody(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequestWithBody(c.Server, workspace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVariable(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVariableRequest(c.Server, workspace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsVariable(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsVariableRequest(c.Server, workspace, path)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVariable(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVariableRequest(c.Server, workspace, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVariable(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVariableRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContextualVariables(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContextualVariablesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariableWithBody(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequestWithBody(c.Server, workspace, path, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVariable(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVariableRequest(c.Server, workspace, path, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUser(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvite(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInviteWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAutoInvite(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAutoInviteRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommandWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditSlackCommand(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditSlackCommandRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhookWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditWebhook(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditWebhookRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, workspace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, workspace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPendingInvites(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPendingInvitesRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPremiumInfo(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPremiumInfoRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkers(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsDomainAllowed(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsDomainAllowedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkspace(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsWorkspace(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsWorkspaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsernameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExistsUsername(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExistsUsernameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspacesAsSuperAdmin(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspacesAsSuperAdminRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkspace(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkspaceRequest(c.Server, workspace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserWorkspaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserWorkspacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetHubAppByIdRequest generates requests for GetHubAppById
func NewGetHubAppByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubAppsRequest generates requests for ListHubApps
func NewListHubAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubFlowByIdRequest generates requests for GetHubFlowById
func NewGetHubFlowByIdRequest(server string, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubFlowsRequest generates requests for ListHubFlows
func NewListHubFlowsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectCallbackRequest calls the generic ConnectCallback builder with application/json body
func NewConnectCallbackRequest(server string, clientName ClientName, body ConnectCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectCallbackRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewConnectCallbackRequestWithBody generates requests for ConnectCallback with any type of body
func NewConnectCallbackRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/connect_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOAuthConnectsRequest generates requests for ListOAuthConnects
func NewListOAuthConnectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/list_connects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOAuthLoginsRequest generates requests for ListOAuthLogins
func NewListOAuthLoginsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/list_logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginWithOauthRequest calls the generic LoginWithOauth builder with application/json body
func NewLoginWithOauthRequest(server string, clientName ClientName, body LoginWithOauthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginWithOauthRequestWithBody(server, clientName, "application/json", bodyReader)
}

// NewLoginWithOauthRequestWithBody generates requests for LoginWithOauth with any type of body
func NewLoginWithOauthRequestWithBody(server string, clientName ClientName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_name", runtime.ParamLocationPath, clientName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/login_callback/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenApiYamlRequest generates requests for GetOpenApiYaml
func NewGetOpenApiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewScheduleRequest calls the generic PreviewSchedule builder with application/json body
func NewPreviewScheduleRequest(server string, body PreviewScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewScheduleRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewScheduleRequestWithBody generates requests for PreviewSchedule with any type of body
func NewPreviewScheduleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBashToJsonschemaRequest calls the generic BashToJsonschema builder with application/json body
func NewBashToJsonschemaRequest(server string, body BashToJsonschemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBashToJsonschemaRequestWithBody(server, "application/json", bodyReader)
}

// NewBashToJsonschemaRequestWithBody generates requests for BashToJsonschema with any type of body
func NewBashToJsonschemaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/bash/tojsonschema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDenoToJsonschemaRequest calls the generic DenoToJsonschema builder with application/json body
func NewDenoToJsonschemaRequest(server string, body DenoToJsonschemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDenoToJsonschemaRequestWithBody(server, "application/json", bodyReader)
}

// NewDenoToJsonschemaRequestWithBody generates requests for DenoToJsonschema with any type of body
func NewDenoToJsonschemaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/deno/tojsonschema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGoToJsonschemaRequest calls the generic GoToJsonschema builder with application/json body
func NewGoToJsonschemaRequest(server string, body GoToJsonschemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGoToJsonschemaRequestWithBody(server, "application/json", bodyReader)
}

// NewGoToJsonschemaRequestWithBody generates requests for GoToJsonschema with any type of body
func NewGoToJsonschemaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/go/tojsonschema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubScriptContentByPathRequest generates requests for GetHubScriptContentByPath
func NewGetHubScriptContentByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubScriptByPathRequest generates requests for GetHubScriptByPath
func NewGetHubScriptByPathRequest(server string, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/get_full/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHubScriptsRequest generates requests for ListHubScripts
func NewListHubScriptsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/hub/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPythonToJsonschemaRequest calls the generic PythonToJsonschema builder with application/json body
func NewPythonToJsonschemaRequest(server string, body PythonToJsonschemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPythonToJsonschemaRequestWithBody(server, "application/json", bodyReader)
}

// NewPythonToJsonschemaRequestWithBody generates requests for PythonToJsonschema with any type of body
func NewPythonToJsonschemaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts/python/tojsonschema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRawScriptByPathTokenedRequest generates requests for RawScriptByPathTokened
func NewRawScriptByPathTokenedRequest(server string, workspace WorkspaceId, token Token, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scripts_u/tokened_raw/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAcceptInviteRequest calls the generic AcceptInvite builder with application/json body
func NewAcceptInviteRequest(server string, body AcceptInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewAcceptInviteRequestWithBody generates requests for AcceptInvite with any type of body
func NewAcceptInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/accept_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserGloballyRequest calls the generic CreateUserGlobally builder with application/json body
func NewCreateUserGloballyRequest(server string, body CreateUserGloballyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserGloballyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserGloballyRequestWithBody generates requests for CreateUserGlobally with any type of body
func NewCreateUserGloballyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeclineInviteRequest calls the generic DeclineInvite builder with application/json body
func NewDeclineInviteRequest(server string, body DeclineInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeclineInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewDeclineInviteRequestWithBody generates requests for DeclineInvite with any type of body
func NewDeclineInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/decline_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGlobalUserDeleteRequest generates requests for GlobalUserDelete
func NewGlobalUserDeleteRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentEmailRequest generates requests for GetCurrentEmail
func NewGetCurrentEmailRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersAsSuperAdminRequest generates requests for ListUsersAsSuperAdmin
func NewListUsersAsSuperAdminRequest(server string, params *ListUsersAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_as_super_admin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspaceInvitesRequest generates requests for ListWorkspaceInvites
func NewListWorkspaceInvitesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/list_invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPasswordRequest calls the generic SetPassword builder with application/json body
func NewSetPasswordRequest(server string, body SetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewSetPasswordRequestWithBody generates requests for SetPassword with any type of body
func NewSetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/setpassword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, tokenPrefix string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_prefix", runtime.ParamLocationPath, tokenPrefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenImpersonateRequest calls the generic CreateTokenImpersonate builder with application/json body
func NewCreateTokenImpersonateRequest(server string, body CreateTokenImpersonateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenImpersonateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenImpersonateRequestWithBody generates requests for CreateTokenImpersonate with any type of body
func NewCreateTokenImpersonateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/impersonate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/tokens/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalUserUpdateRequest calls the generic GlobalUserUpdate builder with application/json body
func NewGlobalUserUpdateRequest(server string, email string, body GlobalUserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGlobalUserUpdateRequestWithBody(server, email, "application/json", bodyReader)
}

// NewGlobalUserUpdateRequestWithBody generates requests for GlobalUserUpdate with any type of body
func NewGlobalUserUpdateRequestWithBody(server string, email string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/update/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageRequest generates requests for GetUsage
func NewGetUsageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalWhoamiRequest generates requests for GlobalWhoami
func NewGlobalWhoamiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/whoami")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBackendVersionRequest generates requests for BackendVersion
func NewBackendVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGranularAclsRequest calls the generic AddGranularAcls builder with application/json body
func NewAddGranularAclsRequest(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewAddGranularAclsRequestWithBody generates requests for AddGranularAcls with any type of body
func NewAddGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/add/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGranularAclsRequest generates requests for GetGranularAcls
func NewGetGranularAclsRequest(server string, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/get/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveGranularAclsRequest calls the generic RemoveGranularAcls builder with application/json body
func NewRemoveGranularAclsRequest(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveGranularAclsRequestWithBody(server, workspace, kind, path, "application/json", bodyReader)
}

// NewRemoveGranularAclsRequestWithBody generates requests for RemoveGranularAcls with any type of body
func NewRemoveGranularAclsRequestWithBody(server string, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "kind", runtime.ParamLocationPath, kind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/acls/remove/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, workspace WorkspaceId, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsAppRequest generates requests for ExistsApp
func NewExistsAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByPathRequest generates requests for GetAppByPath
func NewGetAppByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByVersionRequest generates requests for GetAppByVersion
func NewGetAppByVersionRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/get/v/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, workspace WorkspaceId, params *ListAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPublicSecretOfAppRequest generates requests for GetPublicSecretOfApp
func NewGetPublicSecretOfAppRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/secret_of/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteComponentRequest calls the generic ExecuteComponent builder with application/json body
func NewExecuteComponentRequest(server string, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteComponentRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewExecuteComponentRequestWithBody generates requests for ExecuteComponent with any type of body
func NewExecuteComponentRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/execute_component/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPublicAppBySecretRequest generates requests for GetPublicAppBySecret
func NewGetPublicAppBySecretRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/apps_u/public_app/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuditLogRequest generates requests for GetAuditLog
func NewGetAuditLogRequest(server string, workspace WorkspaceId, id PathId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, workspace WorkspaceId, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/audit/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Username != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Operation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operation", runtime.ParamLocationQuery, *params.Operation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resource != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource", runtime.ParamLocationQuery, *params.Resource); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ActionKind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action_kind", runtime.ParamLocationQuery, *params.ActionKind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptureRequest generates requests for GetCapture
func NewGetCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCaptureRequest generates requests for CreateCapture
func NewCreateCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCaptureRequest generates requests for UpdateCapture
func NewUpdateCaptureRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/capture_u/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStarRequest calls the generic Star builder with application/json body
func NewStarRequest(server string, workspace WorkspaceId, body StarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewStarRequestWithBody generates requests for Star with any type of body
func NewStarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnstarRequest calls the generic Unstar builder with application/json body
func NewUnstarRequest(server string, workspace WorkspaceId, body UnstarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnstarRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUnstarRequestWithBody generates requests for Unstar with any type of body
func NewUnstarRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/favorites/unstar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveFlowByPathRequest calls the generic ArchiveFlowByPath builder with application/json body
func NewArchiveFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveFlowByPathRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewArchiveFlowByPathRequestWithBody generates requests for ArchiveFlowByPath with any type of body
func NewArchiveFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/archive/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFlowRequest calls the generic CreateFlow builder with application/json body
func NewCreateFlowRequest(server string, workspace WorkspaceId, body CreateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlowRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func NewCreateFlowRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowByPathRequest generates requests for DeleteFlowByPath
func NewDeleteFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsFlowByPathRequest generates requests for ExistsFlowByPath
func NewExistsFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowByPathRequest generates requests for GetFlowByPath
func NewGetFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowInputHistoryByPathRequest generates requests for GetFlowInputHistoryByPath
func NewGetFlowInputHistoryByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/input_history/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowsRequest generates requests for ListFlows
func NewListFlowsRequest(server string, workspace WorkspaceId, params *ListFlowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowArchived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFlowPathsRequest generates requests for ListFlowPaths
func NewListFlowPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlowRequest calls the generic UpdateFlow builder with application/json body
func NewUpdateFlowRequest(server string, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateFlowRequestWithBody generates requests for UpdateFlow with any type of body
func NewUpdateFlowRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/flows/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddOwnerToFolderRequest calls the generic AddOwnerToFolder builder with application/json body
func NewAddOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddOwnerToFolderRequestWithBody generates requests for AddOwnerToFolder with any type of body
func NewAddOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/addowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFolderRequest calls the generic CreateFolder builder with application/json body
func NewCreateFolderRequest(server string, workspace WorkspaceId, body CreateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateFolderRequestWithBody generates requests for CreateFolder with any type of body
func NewCreateFolderRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderRequest generates requests for GetFolder
func NewGetFolderRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFolderUsageRequest generates requests for GetFolderUsage
func NewGetFolderUsageRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/getusage/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFoldersRequest generates requests for ListFolders
func NewListFoldersRequest(server string, workspace WorkspaceId, params *ListFoldersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFolderNamesRequest generates requests for ListFolderNames
func NewListFolderNamesRequest(server string, workspace WorkspaceId, params *ListFolderNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OnlyMemberOf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveOwnerToFolderRequest calls the generic RemoveOwnerToFolder builder with application/json body
func NewRemoveOwnerToFolderRequest(server string, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveOwnerToFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveOwnerToFolderRequestWithBody generates requests for RemoveOwnerToFolder with any type of body
func NewRemoveOwnerToFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/removeowner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFolderRequest calls the generic UpdateFolder builder with application/json body
func NewUpdateFolderRequest(server string, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFolderRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateFolderRequestWithBody generates requests for UpdateFolder with any type of body
func NewUpdateFolderRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/folders/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserToGroupRequest calls the generic AddUserToGroup builder with application/json body
func NewAddUserToGroupRequest(server string, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewAddUserToGroupRequestWithBody generates requests for AddUserToGroup with any type of body
func NewAddUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/adduser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, workspace WorkspaceId, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, workspace WorkspaceId, name Name) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, workspace WorkspaceId, params *ListGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupNamesRequest generates requests for ListGroupNames
func NewListGroupNamesRequest(server string, workspace WorkspaceId, params *ListGroupNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OnlyMemberOf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_member_of", runtime.ParamLocationQuery, *params.OnlyMemberOf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserToGroupRequest calls the generic RemoveUserToGroup builder with application/json body
func NewRemoveUserToGroupRequest(server string, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveUserToGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewRemoveUserToGroupRequestWithBody generates requests for RemoveUserToGroup with any type of body
func NewRemoveUserToGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/removeuser/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, workspace, name, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, workspace WorkspaceId, name Name, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/groups/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateInputRequest calls the generic CreateInput builder with application/json body
func NewCreateInputRequest(server string, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInputRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateInputRequestWithBody generates requests for CreateInput with any type of body
func NewCreateInputRequestWithBody(server string, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInputRequest generates requests for DeleteInput
func NewDeleteInputRequest(server string, workspace WorkspaceId, input InputId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "input", runtime.ParamLocationPath, input)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInputHistoryRequest generates requests for GetInputHistory
func NewGetInputHistoryRequest(server string, workspace WorkspaceId, params *GetInputHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInputsRequest generates requests for ListInputs
func NewListInputsRequest(server string, workspace WorkspaceId, params *ListInputsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RunnableId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_id", runtime.ParamLocationQuery, *params.RunnableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RunnableType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "runnable_type", runtime.ParamLocationQuery, *params.RunnableType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInputRequest calls the generic UpdateInput builder with application/json body
func NewUpdateInputRequest(server string, workspace WorkspaceId, body UpdateInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInputRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewUpdateInputRequestWithBody generates requests for UpdateInput with any type of body
func NewUpdateInputRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/inputs/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCompletedJobRequest generates requests for DeleteCompletedJob
func NewDeleteCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobRequest generates requests for GetCompletedJob
func NewGetCompletedJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompletedJobResultRequest generates requests for GetCompletedJobResult
func NewGetCompletedJobResultRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/get_result/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCompletedJobsRequest generates requests for ListCompletedJobs
func NewListCompletedJobsRequest(server string, workspace WorkspaceId, params *ListCompletedJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/completed/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSkipped != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFlowStep != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeSuspendedFlowAsOwnerRequest calls the generic ResumeSuspendedFlowAsOwner builder with application/json body
func NewResumeSuspendedFlowAsOwnerRequest(server string, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedFlowAsOwnerRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewResumeSuspendedFlowAsOwnerRequestWithBody generates requests for ResumeSuspendedFlowAsOwner with any type of body
func NewResumeSuspendedFlowAsOwnerRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/flow/resume/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateJobSignatureRequest generates requests for CreateJobSignature
func NewCreateJobSignatureRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/job_signature/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, workspace WorkspaceId, params *ListJobsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsSkipped != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_skipped", runtime.ParamLocationQuery, *params.IsSkipped); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsFlowStep != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_flow_step", runtime.ParamLocationQuery, *params.IsFlowStep); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQueueRequest generates requests for ListQueue
func NewListQueueRequest(server string, workspace WorkspaceId, params *ListQueueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/queue/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_exact", runtime.ParamLocationQuery, *params.ScriptPathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptPathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_path_start", runtime.ParamLocationQuery, *params.ScriptPathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScriptHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "script_hash", runtime.ParamLocationQuery, *params.ScriptHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_before", runtime.ParamLocationQuery, *params.StartedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_after", runtime.ParamLocationQuery, *params.StartedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Success != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "success", runtime.ParamLocationQuery, *params.Success); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.JobKinds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "job_kinds", runtime.ParamLocationQuery, *params.JobKinds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Suspended != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "suspended", runtime.ParamLocationQuery, *params.Suspended); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Running != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Args != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "args", runtime.ParamLocationQuery, *params.Args); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Result != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "result", runtime.ParamLocationQuery, *params.Result); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResultByIdRequest generates requests for ResultById
func NewResultByIdRequest(server string, workspace WorkspaceId, flowJobId string, nodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "flow_job_id", runtime.ParamLocationPath, flowJobId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "node_id", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/result_by_id/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResumeUrlsRequest generates requests for GetResumeUrls
func NewGetResumeUrlsRequest(server string, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/resume_urls/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunFlowByPathRequest calls the generic RunFlowByPath builder with application/json body
func NewRunFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunFlowByPathRequestWithBody generates requests for RunFlowByPath with any type of body
func NewRunFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByHashRequest calls the generic RunScriptByHash builder with application/json body
func NewRunScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByHashRequestWithBody(server, workspace, hash, params, "application/json", bodyReader)
}

// NewRunScriptByHashRequestWithBody generates requests for RunScriptByHash with any type of body
func NewRunScriptByHashRequestWithBody(server string, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptByPathRequest calls the generic RunScriptByPath builder with application/json body
func NewRunScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunScriptByPathRequestWithBody generates requests for RunScriptByPath with any type of body
func NewRunScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ScheduledFor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_for", runtime.ParamLocationQuery, *params.ScheduledFor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ScheduledInSecs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduled_in_secs", runtime.ParamLocationQuery, *params.ScheduledInSecs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunScriptPreviewRequest calls the generic RunScriptPreview builder with application/json body
func NewRunScriptPreviewRequest(server string, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunScriptPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunScriptPreviewRequestWithBody generates requests for RunScriptPreview with any type of body
func NewRunScriptPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunFlowPreviewRequest calls the generic RunFlowPreview builder with application/json body
func NewRunFlowPreviewRequest(server string, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFlowPreviewRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewRunFlowPreviewRequestWithBody generates requests for RunFlowPreview with any type of body
func NewRunFlowPreviewRequestWithBody(server string, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run/preview_flow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvisibleToOwner != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "invisible_to_owner", runtime.ParamLocationQuery, *params.InvisibleToOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultFlowByPathRequest calls the generic RunWaitResultFlowByPath builder with application/json body
func NewRunWaitResultFlowByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultFlowByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultFlowByPathRequestWithBody generates requests for RunWaitResultFlowByPath with any type of body
func NewRunWaitResultFlowByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/f/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunWaitResultScriptByPathGetRequest generates requests for RunWaitResultScriptByPathGet
func NewRunWaitResultScriptByPathGetRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunWaitResultScriptByPathRequest calls the generic RunWaitResultScriptByPath builder with application/json body
func NewRunWaitResultScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunWaitResultScriptByPathRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewRunWaitResultScriptByPathRequestWithBody generates requests for RunWaitResultScriptByPath with any type of body
func NewRunWaitResultScriptByPathRequestWithBody(server string, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs/run_wait_result/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ParentJob != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_job", runtime.ParamLocationQuery, *params.ParentJob); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeHeader != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_header", runtime.ParamLocationQuery, *params.IncludeHeader); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QueueLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queue_limit", runtime.ParamLocationQuery, *params.QueueLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelSuspendedJobGetRequest generates requests for CancelSuspendedJobGet
func NewCancelSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelSuspendedJobPostRequest calls the generic CancelSuspendedJobPost builder with application/json body
func NewCancelSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewCancelSuspendedJobPostRequestWithBody generates requests for CancelSuspendedJobPost with any type of body
func NewCancelSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/cancel/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, workspace WorkspaceId, id JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSuspendedJobFlowRequest generates requests for GetSuspendedJobFlow
func NewGetSuspendedJobFlowRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/get_flow/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobUpdatesRequest generates requests for GetJobUpdates
func NewGetJobUpdatesRequest(server string, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/getupdate/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Running != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "running", runtime.ParamLocationQuery, *params.Running); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LogOffset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "log_offset", runtime.ParamLocationQuery, *params.LogOffset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelQueuedJobRequest calls the generic CancelQueuedJob builder with application/json body
func NewCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewCancelQueuedJobRequestWithBody generates requests for CancelQueuedJob with any type of body
func NewCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewForceCancelQueuedJobRequest calls the generic ForceCancelQueuedJob builder with application/json body
func NewForceCancelQueuedJobRequest(server string, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForceCancelQueuedJobRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewForceCancelQueuedJobRequestWithBody generates requests for ForceCancelQueuedJob with any type of body
func NewForceCancelQueuedJobRequestWithBody(server string, workspace WorkspaceId, id JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/queue/force_cancel/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResumeSuspendedJobGetRequest generates requests for ResumeSuspendedJobGet
func NewResumeSuspendedJobGetRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Payload != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "payload", runtime.ParamLocationQuery, *params.Payload); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResumeSuspendedJobPostRequest calls the generic ResumeSuspendedJobPost builder with application/json body
func NewResumeSuspendedJobPostRequest(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResumeSuspendedJobPostRequestWithBody(server, workspace, id, resumeId, signature, params, "application/json", bodyReader)
}

// NewResumeSuspendedJobPostRequestWithBody generates requests for ResumeSuspendedJobPost with any type of body
func NewResumeSuspendedJobPostRequestWithBody(server string, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, resumeId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "signature", runtime.ParamLocationPath, signature)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/jobs_u/resume/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Approver != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approver", runtime.ParamLocationQuery, *params.Approver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectSlackCallbackRequest calls the generic ConnectSlackCallback builder with application/json body
func NewConnectSlackCallbackRequest(server string, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectSlackCallbackRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewConnectSlackCallbackRequestWithBody generates requests for ConnectSlackCallback with any type of body
func NewConnectSlackCallbackRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/connect_slack_callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, workspace WorkspaceId, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/create_account", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisconnectAccountRequest generates requests for DisconnectAccount
func NewDisconnectAccountRequest(server string, workspace WorkspaceId, id AccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisconnectSlackRequest generates requests for DisconnectSlack
func NewDisconnectSlackRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/disconnect_slack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, workspace, id, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, workspace WorkspaceId, id AccountId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/oauth/refresh_token/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceRequest calls the generic CreateResource builder with application/json body
func NewCreateResourceRequest(server string, workspace WorkspaceId, body CreateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateResourceRequestWithBody generates requests for CreateResource with any type of body
func NewCreateResourceRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceRequest generates requests for DeleteResource
func NewDeleteResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsResourceRequest generates requests for ExistsResource
func NewExistsResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceValueRequest generates requests for GetResourceValue
func NewGetResourceValueRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/get_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceRequest generates requests for ListResource
func NewListResourceRequest(server string, workspace WorkspaceId, params *ListResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResourceType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type", runtime.ParamLocationQuery, *params.ResourceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ResourceTypeExclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_type_exclude", runtime.ParamLocationQuery, *params.ResourceTypeExclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResourceTypeRequest calls the generic CreateResourceType builder with application/json body
func NewCreateResourceTypeRequest(server string, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceTypeRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateResourceTypeRequestWithBody generates requests for CreateResourceType with any type of body
func NewCreateResourceTypeRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceTypeRequest generates requests for DeleteResourceType
func NewDeleteResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsResourceTypeRequest generates requests for ExistsResourceType
func NewExistsResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceTypeRequest generates requests for GetResourceType
func NewGetResourceTypeRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeRequest generates requests for ListResourceType
func NewListResourceTypeRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListResourceTypeNamesRequest generates requests for ListResourceTypeNames
func NewListResourceTypeNamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/listnames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateResourceTypeRequest calls the generic UpdateResourceType builder with application/json body
func NewUpdateResourceTypeRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceTypeRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceTypeRequestWithBody generates requests for UpdateResourceType with any type of body
func NewUpdateResourceTypeRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/type/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceRequest calls the generic UpdateResource builder with application/json body
func NewUpdateResourceRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceRequestWithBody generates requests for UpdateResource with any type of body
func NewUpdateResourceRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateResourceValueRequest calls the generic UpdateResourceValue builder with application/json body
func NewUpdateResourceValueRequest(server string, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateResourceValueRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateResourceValueRequestWithBody generates requests for UpdateResourceValue with any type of body
func NewUpdateResourceValueRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/resources/update_value/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateScheduleRequest calls the generic CreateSchedule builder with application/json body
func NewCreateScheduleRequest(server string, workspace WorkspaceId, body CreateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScheduleRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScheduleRequestWithBody generates requests for CreateSchedule with any type of body
func NewCreateScheduleRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScheduleRequest generates requests for DeleteSchedule
func NewDeleteScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScheduleRequest generates requests for ExistsSchedule
func NewExistsScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduleRequest generates requests for GetSchedule
func NewGetScheduleRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesRequest generates requests for ListSchedules
func NewListSchedulesRequest(server string, workspace WorkspaceId, params *ListSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetScheduleEnabledRequest calls the generic SetScheduleEnabled builder with application/json body
func NewSetScheduleEnabledRequest(server string, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetScheduleEnabledRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewSetScheduleEnabledRequestWithBody generates requests for SetScheduleEnabled with any type of body
func NewSetScheduleEnabledRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/setenabled/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateScheduleRequest calls the generic UpdateSchedule builder with application/json body
func NewUpdateScheduleRequest(server string, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduleRequestWithBody(server, workspace, path, "application/json", bodyReader)
}

// NewUpdateScheduleRequestWithBody generates requests for UpdateSchedule with any type of body
func NewUpdateScheduleRequestWithBody(server string, workspace WorkspaceId, path Path, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/schedules/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveScriptByHashRequest generates requests for ArchiveScriptByHash
func NewArchiveScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveScriptByPathRequest generates requests for ArchiveScriptByPath
func NewArchiveScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/archive/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateScriptRequest calls the generic CreateScript builder with application/json body
func NewCreateScriptRequest(server string, workspace WorkspaceId, body CreateScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScriptRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateScriptRequestWithBody generates requests for CreateScript with any type of body
func NewCreateScriptRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScriptByHashRequest generates requests for DeleteScriptByHash
func NewDeleteScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteScriptByPathRequest generates requests for DeleteScriptByPath
func NewDeleteScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/delete/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptDeploymentStatusRequest generates requests for GetScriptDeploymentStatus
func NewGetScriptDeploymentStatusRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/deployment_status/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsScriptByPathRequest generates requests for ExistsScriptByPath
func NewExistsScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/exists/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByHashRequest generates requests for GetScriptByHash
func NewGetScriptByHashRequest(server string, workspace WorkspaceId, hash ScriptHash) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScriptByPathRequest generates requests for GetScriptByPath
func NewGetScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/get/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListScriptsRequest generates requests for ListScripts
func NewListScriptsRequest(server string, workspace WorkspaceId, params *ListScriptsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderDesc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_desc", runtime.ParamLocationQuery, *params.OrderDesc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBy != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_by", runtime.ParamLocationQuery, *params.CreatedBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_start", runtime.ParamLocationQuery, *params.PathStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PathExact != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path_exact", runtime.ParamLocationQuery, *params.PathExact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent_hash", runtime.ParamLocationQuery, *params.FirstParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_parent_hash", runtime.ParamLocationQuery, *params.LastParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ParentHash != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent_hash", runtime.ParamLocationQuery, *params.ParentHash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShowArchived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_archived", runtime.ParamLocationQuery, *params.ShowArchived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsTemplate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_template", runtime.ParamLocationQuery, *params.IsTemplate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Kind != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StarredOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starred_only", runtime.ParamLocationQuery, *params.StarredOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListScriptPathsRequest generates requests for ListScriptPaths
func NewListScriptPathsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/list_paths", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByHashRequest generates requests for RawScriptByHash
func NewRawScriptByHashRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/h/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRawScriptByPathRequest generates requests for RawScriptByPath
func NewRawScriptByPathRequest(server string, workspace WorkspaceId, path ScriptPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/scripts/raw/p/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, workspace WorkspaceId, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsOwnerOfPathRequest generates requests for IsOwnerOfPath
func NewIsOwnerOfPathRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/is_owner/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLeaveWorkspaceRequest generates requests for LeaveWorkspace
func NewLeaveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/leave_workspace", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUsernamesRequest generates requests for ListUsernames
func NewListUsernamesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/list_usernames", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, workspace, username, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, workspace WorkspaceId, username string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whoami", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoisRequest generates requests for Whois
func NewWhoisRequest(server string, workspace WorkspaceId, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/users/whois/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVariableRequest calls the generic CreateVariable builder with application/json body
func NewCreateVariableRequest(server string, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVariableRequestWithBody(server, workspace, params, "application/json", bodyReader)
}

// NewCreateVariableRequestWithBody generates requests for CreateVariable with any type of body
func NewCreateVariableRequestWithBody(server string, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AlreadyEncrypted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVariableRequest generates requests for DeleteVariable
func NewDeleteVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/delete/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsVariableRequest generates requests for ExistsVariable
func NewExistsVariableRequest(server string, workspace WorkspaceId, path Path) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/exists/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVariableRequest generates requests for GetVariable
func NewGetVariableRequest(server string, workspace WorkspaceId, path Path, params *GetVariableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/get/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DecryptSecret != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decrypt_secret", runtime.ParamLocationQuery, *params.DecryptSecret); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVariableRequest generates requests for ListVariable
func NewListVariableRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContextualVariablesRequest generates requests for ListContextualVariables
func NewListContextualVariablesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/list_contextual", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVariableRequest calls the generic UpdateVariable builder with application/json body
func NewUpdateVariableRequest(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVariableRequestWithBody(server, workspace, path, params, "application/json", bodyReader)
}

// NewUpdateVariableRequestWithBody generates requests for UpdateVariable with any type of body
func NewUpdateVariableRequestWithBody(server string, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/variables/update/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AlreadyEncrypted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "already_encrypted", runtime.ParamLocationQuery, *params.AlreadyEncrypted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUserRequest calls the generic AddUser builder with application/json body
func NewAddUserRequest(server string, workspace WorkspaceId, body AddUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewAddUserRequestWithBody generates requests for AddUser with any type of body
func NewAddUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/add_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkspaceRequest generates requests for ArchiveWorkspace
func NewArchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInviteRequest calls the generic DeleteInvite builder with application/json body
func NewDeleteInviteRequest(server string, workspace WorkspaceId, body DeleteInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewDeleteInviteRequestWithBody generates requests for DeleteInvite with any type of body
func NewDeleteInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/delete_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditAutoInviteRequest calls the generic EditAutoInvite builder with application/json body
func NewEditAutoInviteRequest(server string, workspace WorkspaceId, body EditAutoInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditAutoInviteRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditAutoInviteRequestWithBody generates requests for EditAutoInvite with any type of body
func NewEditAutoInviteRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_auto_invite", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditSlackCommandRequest calls the generic EditSlackCommand builder with application/json body
func NewEditSlackCommandRequest(server string, workspace WorkspaceId, body EditSlackCommandJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditSlackCommandRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditSlackCommandRequestWithBody generates requests for EditSlackCommand with any type of body
func NewEditSlackCommandRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_slack_command", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditWebhookRequest calls the generic EditWebhook builder with application/json body
func NewEditWebhookRequest(server string, workspace WorkspaceId, body EditWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditWebhookRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewEditWebhookRequestWithBody generates requests for EditWebhook with any type of body
func NewEditWebhookRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/edit_webhook", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/get_settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, workspace WorkspaceId, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, workspace, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, workspace WorkspaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/invite_user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPendingInvitesRequest generates requests for ListPendingInvites
func NewListPendingInvitesRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/list_pending_invites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPremiumInfoRequest generates requests for GetPremiumInfo
func NewGetPremiumInfoRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/w/%s/workspaces/premium_info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkersRequest generates requests for ListWorkers
func NewListWorkersRequest(server string, params *ListWorkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workers/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsDomainAllowedRequest generates requests for IsDomainAllowed
func NewIsDomainAllowedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/allowed_domain_auto_invite")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkspaceRequest calls the generic CreateWorkspace builder with application/json body
func NewCreateWorkspaceRequest(server string, body CreateWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func NewCreateWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWorkspaceRequest generates requests for DeleteWorkspace
func NewDeleteWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExistsWorkspaceRequest calls the generic ExistsWorkspace builder with application/json body
func NewExistsWorkspaceRequest(server string, body ExistsWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsWorkspaceRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsWorkspaceRequestWithBody generates requests for ExistsWorkspace with any type of body
func NewExistsWorkspaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExistsUsernameRequest calls the generic ExistsUsername builder with application/json body
func NewExistsUsernameRequest(server string, body ExistsUsernameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExistsUsernameRequestWithBody(server, "application/json", bodyReader)
}

// NewExistsUsernameRequestWithBody generates requests for ExistsUsername with any type of body
func NewExistsUsernameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/exists_username")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspacesRequest generates requests for ListWorkspaces
func NewListWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkspacesAsSuperAdminRequest generates requests for ListWorkspacesAsSuperAdmin
func NewListWorkspacesAsSuperAdminRequest(server string, params *ListWorkspacesAsSuperAdminParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/list_as_superadmin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveWorkspaceRequest generates requests for UnarchiveWorkspace
func NewUnarchiveWorkspaceRequest(server string, workspace WorkspaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspace", runtime.ParamLocationPath, workspace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/unarchive/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserWorkspacesRequest generates requests for ListUserWorkspaces
func NewListUserWorkspacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspaces/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetHubAppById request
	GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error)

	// ListHubApps request
	ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error)

	// Login request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// GetHubFlowById request
	GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error)

	// ListHubFlows request
	ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error)

	// ConnectCallback request with any body
	ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error)

	// ListOAuthConnects request
	ListOAuthConnectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthConnectsResponse, error)

	// ListOAuthLogins request
	ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error)

	// LoginWithOauth request with any body
	LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error)

	// GetOpenApiYaml request
	GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error)

	// PreviewSchedule request with any body
	PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error)

	// BashToJsonschema request with any body
	BashToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BashToJsonschemaResponse, error)

	BashToJsonschemaWithResponse(ctx context.Context, body BashToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*BashToJsonschemaResponse, error)

	// DenoToJsonschema request with any body
	DenoToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenoToJsonschemaResponse, error)

	DenoToJsonschemaWithResponse(ctx context.Context, body DenoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*DenoToJsonschemaResponse, error)

	// GoToJsonschema request with any body
	GoToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoToJsonschemaResponse, error)

	GoToJsonschemaWithResponse(ctx context.Context, body GoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GoToJsonschemaResponse, error)

	// GetHubScriptContentByPath request
	GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error)

	// GetHubScriptByPath request
	GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error)

	// ListHubScripts request
	ListHubScriptsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubScriptsResponse, error)

	// PythonToJsonschema request with any body
	PythonToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PythonToJsonschemaResponse, error)

	PythonToJsonschemaWithResponse(ctx context.Context, body PythonToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PythonToJsonschemaResponse, error)

	// RawScriptByPathTokened request
	RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error)

	// AcceptInvite request with any body
	AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error)

	// CreateUserGlobally request with any body
	CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error)

	// DeclineInvite request with any body
	DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error)

	// GlobalUserDelete request
	GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error)

	// GetCurrentEmail request
	GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error)

	// ListUsersAsSuperAdmin request
	ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error)

	// ListWorkspaceInvites request
	ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error)

	// SetPassword request with any body
	SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error)

	// CreateToken request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteToken request
	DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// CreateTokenImpersonate request with any body
	CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error)

	// ListTokens request
	ListTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// GlobalUserUpdate request with any body
	GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error)

	// GetUsage request
	GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error)

	// GlobalWhoami request
	GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error)

	// BackendVersion request
	BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error)

	// AddGranularAcls request with any body
	AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error)

	// GetGranularAcls request
	GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error)

	// RemoveGranularAcls request with any body
	RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error)

	// CreateApp request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	// DeleteApp request
	DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	// ExistsApp request
	ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error)

	// GetAppByPath request
	GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error)

	// GetAppByVersion request
	GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error)

	// ListApps request
	ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// GetPublicSecretOfApp request
	GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error)

	// UpdateApp request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// ExecuteComponent request with any body
	ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error)

	// GetPublicAppBySecret request
	GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error)

	// GetAuditLog request
	GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error)

	// ListAuditLogs request
	ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error)

	// GetCapture request
	GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error)

	// CreateCapture request
	CreateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*CreateCaptureResponse, error)

	// UpdateCapture request
	UpdateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*UpdateCaptureResponse, error)

	// Star request with any body
	StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error)

	StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error)

	// Unstar request with any body
	UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error)

	// ArchiveFlowByPath request with any body
	ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error)

	// CreateFlow request with any body
	CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	// DeleteFlowByPath request
	DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error)

	// ExistsFlowByPath request
	ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error)

	// GetFlowByPath request
	GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error)

	// GetFlowInputHistoryByPath request
	GetFlowInputHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*GetFlowInputHistoryByPathResponse, error)

	// ListFlows request
	ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error)

	// ListFlowPaths request
	ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error)

	// UpdateFlow request with any body
	UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	// AddOwnerToFolder request with any body
	AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error)

	// CreateFolder request with any body
	CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	// DeleteFolder request
	DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// GetFolder request
	GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error)

	// GetFolderUsage request
	GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error)

	// ListFolders request
	ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error)

	// ListFolderNames request
	ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error)

	// RemoveOwnerToFolder request with any body
	RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error)

	// UpdateFolder request with any body
	UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	// AddUserToGroup request with any body
	AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	// CreateGroup request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// ListGroupNames request
	ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error)

	// RemoveUserToGroup request with any body
	RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error)

	// UpdateGroup request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// CreateInput request with any body
	CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error)

	// DeleteInput request
	DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error)

	// GetInputHistory request
	GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error)

	// ListInputs request
	ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error)

	// UpdateInput request with any body
	UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error)

	// DeleteCompletedJob request
	DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error)

	// GetCompletedJob request
	GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error)

	// GetCompletedJobResult request
	GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error)

	// ListCompletedJobs request
	ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error)

	// ResumeSuspendedFlowAsOwner request with any body
	ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error)

	// CreateJobSignature request
	CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error)

	// ListJobs request
	ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)

	// ListQueue request
	ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error)

	// ResultById request
	ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error)

	// GetResumeUrls request
	GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error)

	// RunFlowByPath request with any body
	RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error)

	// RunScriptByHash request with any body
	RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error)

	// RunScriptByPath request with any body
	RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error)

	// RunScriptPreview request with any body
	RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error)

	// RunFlowPreview request with any body
	RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error)

	// RunWaitResultFlowByPath request with any body
	RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error)

	// RunWaitResultScriptByPathGet request
	RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error)

	// RunWaitResultScriptByPath request with any body
	RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error)

	// CancelSuspendedJobGet request
	CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error)

	// CancelSuspendedJobPost request with any body
	CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error)

	// GetJob request
	GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// GetSuspendedJobFlow request
	GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error)

	// GetJobUpdates request
	GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error)

	// CancelQueuedJob request with any body
	CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error)

	// ForceCancelQueuedJob request with any body
	ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error)

	// ResumeSuspendedJobGet request
	ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error)

	// ResumeSuspendedJobPost request with any body
	ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error)

	// ConnectSlackCallback request with any body
	ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error)

	// CreateAccount request with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	// DisconnectAccount request
	DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error)

	// DisconnectSlack request
	DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error)

	// RefreshToken request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	// CreateResource request with any body
	CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	// DeleteResource request
	DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// ExistsResource request
	ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error)

	// GetResource request
	GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetResourceValue request
	GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error)

	// ListResource request
	ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error)

	// CreateResourceType request with any body
	CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error)

	// DeleteResourceType request
	DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error)

	// ExistsResourceType request
	ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error)

	// GetResourceType request
	GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error)

	// ListResourceType request
	ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error)

	// ListResourceTypeNames request
	ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error)

	// UpdateResourceType request with any body
	UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error)

	// UpdateResource request with any body
	UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error)

	// UpdateResourceValue request with any body
	UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error)

	// CreateSchedule request with any body
	CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error)

	// DeleteSchedule request
	DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error)

	// ExistsSchedule request
	ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error)

	// GetSchedule request
	GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error)

	// ListSchedules request
	ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error)

	// SetScheduleEnabled request with any body
	SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	// ArchiveScriptByHash request
	ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error)

	// ArchiveScriptByPath request
	ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error)

	// CreateScript request with any body
	CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error)

	// DeleteScriptByHash request
	DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error)

	// DeleteScriptByPath request
	DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error)

	// GetScriptDeploymentStatus request
	GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error)

	// ExistsScriptByPath request
	ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error)

	// GetScriptByHash request
	GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error)

	// GetScriptByPath request
	GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error)

	// ListScripts request
	ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error)

	// ListScriptPaths request
	ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error)

	// RawScriptByHash request
	RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error)

	// RawScriptByPath request
	RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// IsOwnerOfPath request
	IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error)

	// LeaveWorkspace request
	LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// ListUsernames request
	ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// Whoami request
	WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error)

	// Whois request
	WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error)

	// CreateVariable request with any body
	CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error)

	// DeleteVariable request
	DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error)

	// ExistsVariable request
	ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error)

	// GetVariable request
	GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error)

	// ListVariable request
	ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListVariableResponse, error)

	// ListContextualVariables request
	ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error)

	// UpdateVariable request with any body
	UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error)

	// AddUser request with any body
	AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error)

	// ArchiveWorkspace request
	ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error)

	// DeleteInvite request with any body
	DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error)

	// EditAutoInvite request with any body
	EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error)

	// EditSlackCommand request with any body
	EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error)

	// EditWebhook request with any body
	EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error)

	// GetSettings request
	GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// InviteUser request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error)

	// ListPendingInvites request
	ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error)

	// GetPremiumInfo request
	GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error)

	// ListWorkers request
	ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error)

	// IsDomainAllowed request
	IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspace request
	DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// ExistsWorkspace request with any body
	ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error)

	// ExistsUsername request with any body
	ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error)

	// ListWorkspaces request
	ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error)

	// ListWorkspacesAsSuperAdmin request
	ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error)

	// UnarchiveWorkspace request
	UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error)

	// ListUserWorkspaces request
	ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error)
}

type GetHubAppByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		App struct {
			Summary string      `json:"summary"`
			Value   interface{} `json:"value"`
		} `json:"app"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubAppByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubAppByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]struct {
			AppId    float32  `json:"app_id"`
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"apps,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubFlowByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flow *OpenFlow `json:"flow,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubFlowByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubFlowByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flows *[]struct {
			Approved bool     `json:"approved"`
			Apps     []string `json:"apps"`
			FlowId   float32  `json:"flow_id"`
			Id       float32  `json:"id"`
			Summary  string   `json:"summary"`
			Votes    float32  `json:"votes"`
		} `json:"flows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
}

// Status returns HTTPResponse.Status
func (r ConnectCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthConnectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]struct {
			ExtraParams *interface{} `json:"extra_params,omitempty"`
			Scopes      *[]string    `json:"scopes,omitempty"`
		} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOAuthConnectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthConnectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOAuthLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListOAuthLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOAuthLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginWithOauthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginWithOauthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginWithOauthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenApiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenApiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenApiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]time.Time
}

// Status returns HTTPResponse.Status
func (r PreviewScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BashToJsonschemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainArgSignature
}

// Status returns HTTPResponse.Status
func (r BashToJsonschemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BashToJsonschemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DenoToJsonschemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainArgSignature
}

// Status returns HTTPResponse.Status
func (r DenoToJsonschemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DenoToJsonschemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GoToJsonschemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainArgSignature
}

// Status returns HTTPResponse.Status
func (r GoToJsonschemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GoToJsonschemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptContentByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHubScriptContentByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptContentByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content  string       `json:"content"`
		Language string       `json:"language"`
		Lockfile *string      `json:"lockfile,omitempty"`
		Schema   *interface{} `json:"schema,omitempty"`
		Summary  *string      `json:"summary,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetHubScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHubScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Asks *[]struct {
			App      string  `json:"app"`
			Approved bool    `json:"approved"`
			AskId    float32 `json:"ask_id"`
			Id       float32 `json:"id"`
			Kind     string  `json:"kind"`
			Summary  string  `json:"summary"`
			Views    float32 `json:"views"`
			Votes    float32 `json:"votes"`
		} `json:"asks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListHubScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHubScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PythonToJsonschemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MainArgSignature
}

// Status returns HTTPResponse.Status
func (r PythonToJsonschemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PythonToJsonschemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathTokenedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathTokenedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathTokenedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AcceptInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserGloballyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserGloballyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserGloballyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeclineInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeclineInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeclineInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetCurrentEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r ListUsersAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenImpersonateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenImpersonateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenImpersonateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TruncatedToken
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalUserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GlobalUserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalUserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalWhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalUserInfo
}

// Status returns HTTPResponse.Status
func (r GlobalWhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalWhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackendVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BackendVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackendVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]bool `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveGranularAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveGranularAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveGranularAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetAppByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableApp
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicSecretOfAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPublicSecretOfAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicSecretOfAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExecuteComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPublicAppBySecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppWithLastVersion
}

// Status returns HTTPResponse.Status
func (r GetPublicAppBySecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPublicAppBySecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditLog
}

// Status returns HTTPResponse.Status
func (r GetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLog
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnstarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnstarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnstarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
}

// Status returns HTTPResponse.Status
func (r GetFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowInputHistoryByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r GetFlowInputHistoryByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowInputHistoryByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Flow
}

// Status returns HTTPResponse.Status
func (r ListFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListFlowPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Folder
}

// Status returns HTTPResponse.Status
func (r GetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps      float32 `json:"apps"`
		Flows     float32 `json:"flows"`
		Resources float32 `json:"resources"`
		Schedules float32 `json:"schedules"`
		Scripts   float32 `json:"scripts"`
		Variables float32 `json:"variables"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFolderUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Folder
}

// Status returns HTTPResponse.Status
func (r ListFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFolderNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListFolderNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFolderNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveOwnerToFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveOwnerToFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveOwnerToFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Group
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListGroupNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInputHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r GetInputHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInputHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Input
}

// Status returns HTTPResponse.Status
func (r ListInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r DeleteCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompletedJob
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompletedJobResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetCompletedJobResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompletedJobResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCompletedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CompletedJob
}

// Status returns HTTPResponse.Status
func (r ListCompletedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCompletedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedFlowAsOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedFlowAsOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedFlowAsOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobSignatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateJobSignatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobSignatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Job
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]QueuedJob
}

// Status returns HTTPResponse.Status
func (r ListQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResultByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ResultByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResultByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResumeUrlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ApprovalPage string `json:"approvalPage"`
		Cancel       string `json:"cancel"`
		Resume       string `json:"resume"`
	}
}

// Status returns HTTPResponse.Status
func (r GetResumeUrlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResumeUrlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunScriptPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunScriptPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunScriptPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFlowPreviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RunFlowPreviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFlowPreviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultFlowByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultFlowByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultFlowByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunWaitResultScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r RunWaitResultScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunWaitResultScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSuspendedJobFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Approvers []struct {
			Approver string `json:"approver"`
			ResumeId int    `json:"resume_id"`
		} `json:"approvers"`
		Job Job `json:"job"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSuspendedJobFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSuspendedJobFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Completed *bool   `json:"completed,omitempty"`
		MemPeak   *int    `json:"mem_peak,omitempty"`
		NewLogs   *string `json:"new_logs,omitempty"`
		Running   *bool   `json:"running,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJobUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForceCancelQueuedJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ForceCancelQueuedJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForceCancelQueuedJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSuspendedJobPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResumeSuspendedJobPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSuspendedJobPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectSlackCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ConnectSlackCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectSlackCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisconnectSlackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisconnectSlackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisconnectSlackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableResource
}

// Status returns HTTPResponse.Status
func (r ListResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceType
}

// Status returns HTTPResponse.Status
func (r GetResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ResourceType
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResourceTypeNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListResourceTypeNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResourceTypeNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResourceValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateResourceValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResourceValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedule
}

// Status returns HTTPResponse.Status
func (r GetScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Schedule
}

// Status returns HTTPResponse.Status
func (r ListSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetScheduleEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetScheduleEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetScheduleEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DeleteScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Lock          *string `json:"lock,omitempty"`
		LockErrorLogs *string `json:"lock_error_logs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetScriptDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Script
}

// Status returns HTTPResponse.Status
func (r GetScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Script
}

// Status returns HTTPResponse.Status
func (r ListScriptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScriptPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ListScriptPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScriptPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawScriptByPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RawScriptByPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawScriptByPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsOwnerOfPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsOwnerOfPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsOwnerOfPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LeaveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]User
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsernamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListUsernamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsernamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r WhoisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r ExistsVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListableVariable
}

// Status returns HTTPResponse.Status
func (r GetVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListableVariable
}

// Status returns HTTPResponse.Status
func (r ListVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContextualVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ContextualVariable
}

// Status returns HTTPResponse.Status
func (r ListContextualVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextualVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAutoInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditAutoInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAutoInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditSlackCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditSlackCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditSlackCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AutoInviteDomain   *string `json:"auto_invite_domain,omitempty"`
		AutoInviteOperator *bool   `json:"auto_invite_operator,omitempty"`
		CustomerId         *string `json:"customer_id,omitempty"`
		Plan               *string `json:"plan,omitempty"`
		SlackCommandScript *string `json:"slack_command_script,omitempty"`
		SlackName          *string `json:"slack_name,omitempty"`
		SlackTeamId        *string `json:"slack_team_id,omitempty"`
		Webhook            *string `json:"webhook,omitempty"`
		WorkspaceId        *string `json:"workspace_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPendingInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkspaceInvite
}

// Status returns HTTPResponse.Status
func (r ListPendingInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPendingInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPremiumInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Premium bool     `json:"premium"`
		Usage   *float32 `json:"usage,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPremiumInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPremiumInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerPing
}

// Status returns HTTPResponse.Status
func (r ListWorkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsDomainAllowedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r IsDomainAllowedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsDomainAllowedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExistsUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExistsUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExistsUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspacesAsSuperAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Workspace
}

// Status returns HTTPResponse.Status
func (r ListWorkspacesAsSuperAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspacesAsSuperAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserWorkspaceList
}

// Status returns HTTPResponse.Status
func (r ListUserWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetHubAppByIdWithResponse request returning *GetHubAppByIdResponse
func (c *ClientWithResponses) GetHubAppByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubAppByIdResponse, error) {
	rsp, err := c.GetHubAppById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubAppByIdResponse(rsp)
}

// ListHubAppsWithResponse request returning *ListHubAppsResponse
func (c *ClientWithResponses) ListHubAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubAppsResponse, error) {
	rsp, err := c.ListHubApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubAppsResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// GetHubFlowByIdWithResponse request returning *GetHubFlowByIdResponse
func (c *ClientWithResponses) GetHubFlowByIdWithResponse(ctx context.Context, id PathId, reqEditors ...RequestEditorFn) (*GetHubFlowByIdResponse, error) {
	rsp, err := c.GetHubFlowById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubFlowByIdResponse(rsp)
}

// ListHubFlowsWithResponse request returning *ListHubFlowsResponse
func (c *ClientWithResponses) ListHubFlowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubFlowsResponse, error) {
	rsp, err := c.ListHubFlows(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubFlowsResponse(rsp)
}

// ConnectCallbackWithBodyWithResponse request with arbitrary body returning *ConnectCallbackResponse
func (c *ClientWithResponses) ConnectCallbackWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallbackWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectCallbackWithResponse(ctx context.Context, clientName ClientName, body ConnectCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectCallbackResponse, error) {
	rsp, err := c.ConnectCallback(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectCallbackResponse(rsp)
}

// ListOAuthConnectsWithResponse request returning *ListOAuthConnectsResponse
func (c *ClientWithResponses) ListOAuthConnectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthConnectsResponse, error) {
	rsp, err := c.ListOAuthConnects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthConnectsResponse(rsp)
}

// ListOAuthLoginsWithResponse request returning *ListOAuthLoginsResponse
func (c *ClientWithResponses) ListOAuthLoginsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOAuthLoginsResponse, error) {
	rsp, err := c.ListOAuthLogins(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOAuthLoginsResponse(rsp)
}

// LoginWithOauthWithBodyWithResponse request with arbitrary body returning *LoginWithOauthResponse
func (c *ClientWithResponses) LoginWithOauthWithBodyWithResponse(ctx context.Context, clientName ClientName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauthWithBody(ctx, clientName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

func (c *ClientWithResponses) LoginWithOauthWithResponse(ctx context.Context, clientName ClientName, body LoginWithOauthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginWithOauthResponse, error) {
	rsp, err := c.LoginWithOauth(ctx, clientName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginWithOauthResponse(rsp)
}

// GetOpenApiYamlWithResponse request returning *GetOpenApiYamlResponse
func (c *ClientWithResponses) GetOpenApiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenApiYamlResponse, error) {
	rsp, err := c.GetOpenApiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenApiYamlResponse(rsp)
}

// PreviewScheduleWithBodyWithResponse request with arbitrary body returning *PreviewScheduleResponse
func (c *ClientWithResponses) PreviewScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewScheduleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

func (c *ClientWithResponses) PreviewScheduleWithResponse(ctx context.Context, body PreviewScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewScheduleResponse, error) {
	rsp, err := c.PreviewSchedule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewScheduleResponse(rsp)
}

// BashToJsonschemaWithBodyWithResponse request with arbitrary body returning *BashToJsonschemaResponse
func (c *ClientWithResponses) BashToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BashToJsonschemaResponse, error) {
	rsp, err := c.BashToJsonschemaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBashToJsonschemaResponse(rsp)
}

func (c *ClientWithResponses) BashToJsonschemaWithResponse(ctx context.Context, body BashToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*BashToJsonschemaResponse, error) {
	rsp, err := c.BashToJsonschema(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBashToJsonschemaResponse(rsp)
}

// DenoToJsonschemaWithBodyWithResponse request with arbitrary body returning *DenoToJsonschemaResponse
func (c *ClientWithResponses) DenoToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenoToJsonschemaResponse, error) {
	rsp, err := c.DenoToJsonschemaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenoToJsonschemaResponse(rsp)
}

func (c *ClientWithResponses) DenoToJsonschemaWithResponse(ctx context.Context, body DenoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*DenoToJsonschemaResponse, error) {
	rsp, err := c.DenoToJsonschema(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenoToJsonschemaResponse(rsp)
}

// GoToJsonschemaWithBodyWithResponse request with arbitrary body returning *GoToJsonschemaResponse
func (c *ClientWithResponses) GoToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoToJsonschemaResponse, error) {
	rsp, err := c.GoToJsonschemaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoToJsonschemaResponse(rsp)
}

func (c *ClientWithResponses) GoToJsonschemaWithResponse(ctx context.Context, body GoToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*GoToJsonschemaResponse, error) {
	rsp, err := c.GoToJsonschema(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoToJsonschemaResponse(rsp)
}

// GetHubScriptContentByPathWithResponse request returning *GetHubScriptContentByPathResponse
func (c *ClientWithResponses) GetHubScriptContentByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptContentByPathResponse, error) {
	rsp, err := c.GetHubScriptContentByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptContentByPathResponse(rsp)
}

// GetHubScriptByPathWithResponse request returning *GetHubScriptByPathResponse
func (c *ClientWithResponses) GetHubScriptByPathWithResponse(ctx context.Context, path ScriptPath, reqEditors ...RequestEditorFn) (*GetHubScriptByPathResponse, error) {
	rsp, err := c.GetHubScriptByPath(ctx, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubScriptByPathResponse(rsp)
}

// ListHubScriptsWithResponse request returning *ListHubScriptsResponse
func (c *ClientWithResponses) ListHubScriptsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListHubScriptsResponse, error) {
	rsp, err := c.ListHubScripts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHubScriptsResponse(rsp)
}

// PythonToJsonschemaWithBodyWithResponse request with arbitrary body returning *PythonToJsonschemaResponse
func (c *ClientWithResponses) PythonToJsonschemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PythonToJsonschemaResponse, error) {
	rsp, err := c.PythonToJsonschemaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePythonToJsonschemaResponse(rsp)
}

func (c *ClientWithResponses) PythonToJsonschemaWithResponse(ctx context.Context, body PythonToJsonschemaJSONRequestBody, reqEditors ...RequestEditorFn) (*PythonToJsonschemaResponse, error) {
	rsp, err := c.PythonToJsonschema(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePythonToJsonschemaResponse(rsp)
}

// RawScriptByPathTokenedWithResponse request returning *RawScriptByPathTokenedResponse
func (c *ClientWithResponses) RawScriptByPathTokenedWithResponse(ctx context.Context, workspace WorkspaceId, token Token, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathTokenedResponse, error) {
	rsp, err := c.RawScriptByPathTokened(ctx, workspace, token, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathTokenedResponse(rsp)
}

// AcceptInviteWithBodyWithResponse request with arbitrary body returning *AcceptInviteResponse
func (c *ClientWithResponses) AcceptInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

func (c *ClientWithResponses) AcceptInviteWithResponse(ctx context.Context, body AcceptInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInviteResponse, error) {
	rsp, err := c.AcceptInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInviteResponse(rsp)
}

// CreateUserGloballyWithBodyWithResponse request with arbitrary body returning *CreateUserGloballyResponse
func (c *ClientWithResponses) CreateUserGloballyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGloballyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

func (c *ClientWithResponses) CreateUserGloballyWithResponse(ctx context.Context, body CreateUserGloballyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserGloballyResponse, error) {
	rsp, err := c.CreateUserGlobally(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserGloballyResponse(rsp)
}

// DeclineInviteWithBodyWithResponse request with arbitrary body returning *DeclineInviteResponse
func (c *ClientWithResponses) DeclineInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

func (c *ClientWithResponses) DeclineInviteWithResponse(ctx context.Context, body DeclineInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeclineInviteResponse, error) {
	rsp, err := c.DeclineInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeclineInviteResponse(rsp)
}

// GlobalUserDeleteWithResponse request returning *GlobalUserDeleteResponse
func (c *ClientWithResponses) GlobalUserDeleteWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*GlobalUserDeleteResponse, error) {
	rsp, err := c.GlobalUserDelete(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserDeleteResponse(rsp)
}

// GetCurrentEmailWithResponse request returning *GetCurrentEmailResponse
func (c *ClientWithResponses) GetCurrentEmailWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentEmailResponse, error) {
	rsp, err := c.GetCurrentEmail(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentEmailResponse(rsp)
}

// ListUsersAsSuperAdminWithResponse request returning *ListUsersAsSuperAdminResponse
func (c *ClientWithResponses) ListUsersAsSuperAdminWithResponse(ctx context.Context, params *ListUsersAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListUsersAsSuperAdminResponse, error) {
	rsp, err := c.ListUsersAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersAsSuperAdminResponse(rsp)
}

// ListWorkspaceInvitesWithResponse request returning *ListWorkspaceInvitesResponse
func (c *ClientWithResponses) ListWorkspaceInvitesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspaceInvitesResponse, error) {
	rsp, err := c.ListWorkspaceInvites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceInvitesResponse(rsp)
}

// SetPasswordWithBodyWithResponse request with arbitrary body returning *SetPasswordResponse
func (c *ClientWithResponses) SetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

func (c *ClientWithResponses) SetPasswordWithResponse(ctx context.Context, body SetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*SetPasswordResponse, error) {
	rsp, err := c.SetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPasswordResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, tokenPrefix string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, tokenPrefix, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// CreateTokenImpersonateWithBodyWithResponse request with arbitrary body returning *CreateTokenImpersonateResponse
func (c *ClientWithResponses) CreateTokenImpersonateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenImpersonateWithResponse(ctx context.Context, body CreateTokenImpersonateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenImpersonateResponse, error) {
	rsp, err := c.CreateTokenImpersonate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenImpersonateResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// GlobalUserUpdateWithBodyWithResponse request with arbitrary body returning *GlobalUserUpdateResponse
func (c *ClientWithResponses) GlobalUserUpdateWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdateWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) GlobalUserUpdateWithResponse(ctx context.Context, email string, body GlobalUserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GlobalUserUpdateResponse, error) {
	rsp, err := c.GlobalUserUpdate(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalUserUpdateResponse(rsp)
}

// GetUsageWithResponse request returning *GetUsageResponse
func (c *ClientWithResponses) GetUsageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageResponse, error) {
	rsp, err := c.GetUsage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageResponse(rsp)
}

// GlobalWhoamiWithResponse request returning *GlobalWhoamiResponse
func (c *ClientWithResponses) GlobalWhoamiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalWhoamiResponse, error) {
	rsp, err := c.GlobalWhoami(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalWhoamiResponse(rsp)
}

// BackendVersionWithResponse request returning *BackendVersionResponse
func (c *ClientWithResponses) BackendVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BackendVersionResponse, error) {
	rsp, err := c.BackendVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackendVersionResponse(rsp)
}

// AddGranularAclsWithBodyWithResponse request with arbitrary body returning *AddGranularAclsResponse
func (c *ClientWithResponses) AddGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) AddGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path, body AddGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGranularAclsResponse, error) {
	rsp, err := c.AddGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGranularAclsResponse(rsp)
}

// GetGranularAclsWithResponse request returning *GetGranularAclsResponse
func (c *ClientWithResponses) GetGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path, reqEditors ...RequestEditorFn) (*GetGranularAclsResponse, error) {
	rsp, err := c.GetGranularAcls(ctx, workspace, kind, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGranularAclsResponse(rsp)
}

// RemoveGranularAclsWithBodyWithResponse request with arbitrary body returning *RemoveGranularAclsResponse
func (c *ClientWithResponses) RemoveGranularAclsWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAclsWithBody(ctx, workspace, kind, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

func (c *ClientWithResponses) RemoveGranularAclsWithResponse(ctx context.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path, body RemoveGranularAclsJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveGranularAclsResponse, error) {
	rsp, err := c.RemoveGranularAcls(ctx, workspace, kind, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveGranularAclsResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateApp(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

// ExistsAppWithResponse request returning *ExistsAppResponse
func (c *ClientWithResponses) ExistsAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsAppResponse, error) {
	rsp, err := c.ExistsApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsAppResponse(rsp)
}

// GetAppByPathWithResponse request returning *GetAppByPathResponse
func (c *ClientWithResponses) GetAppByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetAppByPathResponse, error) {
	rsp, err := c.GetAppByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByPathResponse(rsp)
}

// GetAppByVersionWithResponse request returning *GetAppByVersionResponse
func (c *ClientWithResponses) GetAppByVersionWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAppByVersionResponse, error) {
	rsp, err := c.GetAppByVersion(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByVersionResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// GetPublicSecretOfAppWithResponse request returning *GetPublicSecretOfAppResponse
func (c *ClientWithResponses) GetPublicSecretOfAppWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicSecretOfAppResponse, error) {
	rsp, err := c.GetPublicSecretOfApp(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicSecretOfAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// ExecuteComponentWithBodyWithResponse request with arbitrary body returning *ExecuteComponentResponse
func (c *ClientWithResponses) ExecuteComponentWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponentWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

func (c *ClientWithResponses) ExecuteComponentWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ExecuteComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteComponentResponse, error) {
	rsp, err := c.ExecuteComponent(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteComponentResponse(rsp)
}

// GetPublicAppBySecretWithResponse request returning *GetPublicAppBySecretResponse
func (c *ClientWithResponses) GetPublicAppBySecretWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetPublicAppBySecretResponse, error) {
	rsp, err := c.GetPublicAppBySecret(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPublicAppBySecretResponse(rsp)
}

// GetAuditLogWithResponse request returning *GetAuditLogResponse
func (c *ClientWithResponses) GetAuditLogWithResponse(ctx context.Context, workspace WorkspaceId, id PathId, reqEditors ...RequestEditorFn) (*GetAuditLogResponse, error) {
	rsp, err := c.GetAuditLog(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuditLogResponse(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResponse
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResponse, error) {
	rsp, err := c.ListAuditLogs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResponse(rsp)
}

// GetCaptureWithResponse request returning *GetCaptureResponse
func (c *ClientWithResponses) GetCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetCaptureResponse, error) {
	rsp, err := c.GetCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureResponse(rsp)
}

// CreateCaptureWithResponse request returning *CreateCaptureResponse
func (c *ClientWithResponses) CreateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*CreateCaptureResponse, error) {
	rsp, err := c.CreateCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaptureResponse(rsp)
}

// UpdateCaptureWithResponse request returning *UpdateCaptureResponse
func (c *ClientWithResponses) UpdateCaptureWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*UpdateCaptureResponse, error) {
	rsp, err := c.UpdateCapture(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaptureResponse(rsp)
}

// StarWithBodyWithResponse request with arbitrary body returning *StarResponse
func (c *ClientWithResponses) StarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.StarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

func (c *ClientWithResponses) StarWithResponse(ctx context.Context, workspace WorkspaceId, body StarJSONRequestBody, reqEditors ...RequestEditorFn) (*StarResponse, error) {
	rsp, err := c.Star(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStarResponse(rsp)
}

// UnstarWithBodyWithResponse request with arbitrary body returning *UnstarResponse
func (c *ClientWithResponses) UnstarWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.UnstarWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

func (c *ClientWithResponses) UnstarWithResponse(ctx context.Context, workspace WorkspaceId, body UnstarJSONRequestBody, reqEditors ...RequestEditorFn) (*UnstarResponse, error) {
	rsp, err := c.Unstar(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnstarResponse(rsp)
}

// ArchiveFlowByPathWithBodyWithResponse request with arbitrary body returning *ArchiveFlowByPathResponse
func (c *ClientWithResponses) ArchiveFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPathWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) ArchiveFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body ArchiveFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFlowByPathResponse, error) {
	rsp, err := c.ArchiveFlowByPath(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFlowByPathResponse(rsp)
}

// CreateFlowWithBodyWithResponse request with arbitrary body returning *CreateFlowResponse
func (c *ClientWithResponses) CreateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlowWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateFlowWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlow(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

// DeleteFlowByPathWithResponse request returning *DeleteFlowByPathResponse
func (c *ClientWithResponses) DeleteFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteFlowByPathResponse, error) {
	rsp, err := c.DeleteFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowByPathResponse(rsp)
}

// ExistsFlowByPathWithResponse request returning *ExistsFlowByPathResponse
func (c *ClientWithResponses) ExistsFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsFlowByPathResponse, error) {
	rsp, err := c.ExistsFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsFlowByPathResponse(rsp)
}

// GetFlowByPathWithResponse request returning *GetFlowByPathResponse
func (c *ClientWithResponses) GetFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetFlowByPathResponse, error) {
	rsp, err := c.GetFlowByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowByPathResponse(rsp)
}

// GetFlowInputHistoryByPathWithResponse request returning *GetFlowInputHistoryByPathResponse
func (c *ClientWithResponses) GetFlowInputHistoryByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *GetFlowInputHistoryByPathParams, reqEditors ...RequestEditorFn) (*GetFlowInputHistoryByPathResponse, error) {
	rsp, err := c.GetFlowInputHistoryByPath(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowInputHistoryByPathResponse(rsp)
}

// ListFlowsWithResponse request returning *ListFlowsResponse
func (c *ClientWithResponses) ListFlowsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error) {
	rsp, err := c.ListFlows(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowsResponse(rsp)
}

// ListFlowPathsWithResponse request returning *ListFlowPathsResponse
func (c *ClientWithResponses) ListFlowPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListFlowPathsResponse, error) {
	rsp, err := c.ListFlowPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowPathsResponse(rsp)
}

// UpdateFlowWithBodyWithResponse request with arbitrary body returning *UpdateFlowResponse
func (c *ClientWithResponses) UpdateFlowWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlowWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlow(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

// AddOwnerToFolderWithBodyWithResponse request with arbitrary body returning *AddOwnerToFolderResponse
func (c *ClientWithResponses) AddOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) AddOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOwnerToFolderResponse, error) {
	rsp, err := c.AddOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOwnerToFolderResponse(rsp)
}

// CreateFolderWithBodyWithResponse request with arbitrary body returning *CreateFolderResponse
func (c *ClientWithResponses) CreateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolderWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderWithResponse(ctx context.Context, workspace WorkspaceId, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolder(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// GetFolderWithResponse request returning *GetFolderResponse
func (c *ClientWithResponses) GetFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderResponse, error) {
	rsp, err := c.GetFolder(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderResponse(rsp)
}

// GetFolderUsageWithResponse request returning *GetFolderUsageResponse
func (c *ClientWithResponses) GetFolderUsageWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetFolderUsageResponse, error) {
	rsp, err := c.GetFolderUsage(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderUsageResponse(rsp)
}

// ListFoldersWithResponse request returning *ListFoldersResponse
func (c *ClientWithResponses) ListFoldersWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error) {
	rsp, err := c.ListFolders(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFoldersResponse(rsp)
}

// ListFolderNamesWithResponse request returning *ListFolderNamesResponse
func (c *ClientWithResponses) ListFolderNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListFolderNamesParams, reqEditors ...RequestEditorFn) (*ListFolderNamesResponse, error) {
	rsp, err := c.ListFolderNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFolderNamesResponse(rsp)
}

// RemoveOwnerToFolderWithBodyWithResponse request with arbitrary body returning *RemoveOwnerToFolderResponse
func (c *ClientWithResponses) RemoveOwnerToFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

func (c *ClientWithResponses) RemoveOwnerToFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveOwnerToFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveOwnerToFolderResponse, error) {
	rsp, err := c.RemoveOwnerToFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveOwnerToFolderResponse(rsp)
}

// UpdateFolderWithBodyWithResponse request with arbitrary body returning *UpdateFolderResponse
func (c *ClientWithResponses) UpdateFolderWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolderWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateFolderWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolder(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

// AddUserToGroupWithBodyWithResponse request with arbitrary body returning *AddUserToGroupResponse
func (c *ClientWithResponses) AddUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, workspace WorkspaceId, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, workspace, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// ListGroupNamesWithResponse request returning *ListGroupNamesResponse
func (c *ClientWithResponses) ListGroupNamesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListGroupNamesParams, reqEditors ...RequestEditorFn) (*ListGroupNamesResponse, error) {
	rsp, err := c.ListGroupNames(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupNamesResponse(rsp)
}

// RemoveUserToGroupWithBodyWithResponse request with arbitrary body returning *RemoveUserToGroupResponse
func (c *ClientWithResponses) RemoveUserToGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveUserToGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body RemoveUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveUserToGroupResponse, error) {
	rsp, err := c.RemoveUserToGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserToGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, name Name, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, workspace, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, workspace WorkspaceId, name Name, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, workspace, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// CreateInputWithBodyWithResponse request with arbitrary body returning *CreateInputResponse
func (c *ClientWithResponses) CreateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInputWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

func (c *ClientWithResponses) CreateInputWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateInputParams, body CreateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInputResponse, error) {
	rsp, err := c.CreateInput(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInputResponse(rsp)
}

// DeleteInputWithResponse request returning *DeleteInputResponse
func (c *ClientWithResponses) DeleteInputWithResponse(ctx context.Context, workspace WorkspaceId, input InputId, reqEditors ...RequestEditorFn) (*DeleteInputResponse, error) {
	rsp, err := c.DeleteInput(ctx, workspace, input, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInputResponse(rsp)
}

// GetInputHistoryWithResponse request returning *GetInputHistoryResponse
func (c *ClientWithResponses) GetInputHistoryWithResponse(ctx context.Context, workspace WorkspaceId, params *GetInputHistoryParams, reqEditors ...RequestEditorFn) (*GetInputHistoryResponse, error) {
	rsp, err := c.GetInputHistory(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInputHistoryResponse(rsp)
}

// ListInputsWithResponse request returning *ListInputsResponse
func (c *ClientWithResponses) ListInputsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListInputsParams, reqEditors ...RequestEditorFn) (*ListInputsResponse, error) {
	rsp, err := c.ListInputs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInputsResponse(rsp)
}

// UpdateInputWithBodyWithResponse request with arbitrary body returning *UpdateInputResponse
func (c *ClientWithResponses) UpdateInputWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInputWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

func (c *ClientWithResponses) UpdateInputWithResponse(ctx context.Context, workspace WorkspaceId, body UpdateInputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInputResponse, error) {
	rsp, err := c.UpdateInput(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInputResponse(rsp)
}

// DeleteCompletedJobWithResponse request returning *DeleteCompletedJobResponse
func (c *ClientWithResponses) DeleteCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*DeleteCompletedJobResponse, error) {
	rsp, err := c.DeleteCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCompletedJobResponse(rsp)
}

// GetCompletedJobWithResponse request returning *GetCompletedJobResponse
func (c *ClientWithResponses) GetCompletedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResponse, error) {
	rsp, err := c.GetCompletedJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResponse(rsp)
}

// GetCompletedJobResultWithResponse request returning *GetCompletedJobResultResponse
func (c *ClientWithResponses) GetCompletedJobResultWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetCompletedJobResultResponse, error) {
	rsp, err := c.GetCompletedJobResult(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompletedJobResultResponse(rsp)
}

// ListCompletedJobsWithResponse request returning *ListCompletedJobsResponse
func (c *ClientWithResponses) ListCompletedJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListCompletedJobsParams, reqEditors ...RequestEditorFn) (*ListCompletedJobsResponse, error) {
	rsp, err := c.ListCompletedJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCompletedJobsResponse(rsp)
}

// ResumeSuspendedFlowAsOwnerWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedFlowAsOwnerResponse
func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwnerWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedFlowAsOwnerWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ResumeSuspendedFlowAsOwnerJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	rsp, err := c.ResumeSuspendedFlowAsOwner(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedFlowAsOwnerResponse(rsp)
}

// CreateJobSignatureWithResponse request returning *CreateJobSignatureResponse
func (c *ClientWithResponses) CreateJobSignatureWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *CreateJobSignatureParams, reqEditors ...RequestEditorFn) (*CreateJobSignatureResponse, error) {
	rsp, err := c.CreateJobSignature(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobSignatureResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// ListQueueWithResponse request returning *ListQueueResponse
func (c *ClientWithResponses) ListQueueWithResponse(ctx context.Context, workspace WorkspaceId, params *ListQueueParams, reqEditors ...RequestEditorFn) (*ListQueueResponse, error) {
	rsp, err := c.ListQueue(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQueueResponse(rsp)
}

// ResultByIdWithResponse request returning *ResultByIdResponse
func (c *ClientWithResponses) ResultByIdWithResponse(ctx context.Context, workspace WorkspaceId, flowJobId string, nodeId string, reqEditors ...RequestEditorFn) (*ResultByIdResponse, error) {
	rsp, err := c.ResultById(ctx, workspace, flowJobId, nodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResultByIdResponse(rsp)
}

// GetResumeUrlsWithResponse request returning *GetResumeUrlsResponse
func (c *ClientWithResponses) GetResumeUrlsWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, params *GetResumeUrlsParams, reqEditors ...RequestEditorFn) (*GetResumeUrlsResponse, error) {
	rsp, err := c.GetResumeUrls(ctx, workspace, id, resumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResumeUrlsResponse(rsp)
}

// RunFlowByPathWithBodyWithResponse request with arbitrary body returning *RunFlowByPathResponse
func (c *ClientWithResponses) RunFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunFlowByPathParams, body RunFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowByPathResponse, error) {
	rsp, err := c.RunFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowByPathResponse(rsp)
}

// RunScriptByHashWithBodyWithResponse request with arbitrary body returning *RunScriptByHashResponse
func (c *ClientWithResponses) RunScriptByHashWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHashWithBody(ctx, workspace, hash, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, params *RunScriptByHashParams, body RunScriptByHashJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByHashResponse, error) {
	rsp, err := c.RunScriptByHash(ctx, workspace, hash, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByHashResponse(rsp)
}

// RunScriptByPathWithBodyWithResponse request with arbitrary body returning *RunScriptByPathResponse
func (c *ClientWithResponses) RunScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunScriptByPathParams, body RunScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptByPathResponse, error) {
	rsp, err := c.RunScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptByPathResponse(rsp)
}

// RunScriptPreviewWithBodyWithResponse request with arbitrary body returning *RunScriptPreviewResponse
func (c *ClientWithResponses) RunScriptPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunScriptPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunScriptPreviewParams, body RunScriptPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunScriptPreviewResponse, error) {
	rsp, err := c.RunScriptPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunScriptPreviewResponse(rsp)
}

// RunFlowPreviewWithBodyWithResponse request with arbitrary body returning *RunFlowPreviewResponse
func (c *ClientWithResponses) RunFlowPreviewWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreviewWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

func (c *ClientWithResponses) RunFlowPreviewWithResponse(ctx context.Context, workspace WorkspaceId, params *RunFlowPreviewParams, body RunFlowPreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFlowPreviewResponse, error) {
	rsp, err := c.RunFlowPreview(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFlowPreviewResponse(rsp)
}

// RunWaitResultFlowByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultFlowByPathResponse
func (c *ClientWithResponses) RunWaitResultFlowByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultFlowByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultFlowByPathParams, body RunWaitResultFlowByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultFlowByPathResponse, error) {
	rsp, err := c.RunWaitResultFlowByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultFlowByPathResponse(rsp)
}

// RunWaitResultScriptByPathGetWithResponse request returning *RunWaitResultScriptByPathGetResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathGetWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathGetParams, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathGetResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathGet(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathGetResponse(rsp)
}

// RunWaitResultScriptByPathWithBodyWithResponse request with arbitrary body returning *RunWaitResultScriptByPathResponse
func (c *ClientWithResponses) RunWaitResultScriptByPathWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPathWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

func (c *ClientWithResponses) RunWaitResultScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, params *RunWaitResultScriptByPathParams, body RunWaitResultScriptByPathJSONRequestBody, reqEditors ...RequestEditorFn) (*RunWaitResultScriptByPathResponse, error) {
	rsp, err := c.RunWaitResultScriptByPath(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunWaitResultScriptByPathResponse(rsp)
}

// CancelSuspendedJobGetWithResponse request returning *CancelSuspendedJobGetResponse
func (c *ClientWithResponses) CancelSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*CancelSuspendedJobGetResponse, error) {
	rsp, err := c.CancelSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobGetResponse(rsp)
}

// CancelSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *CancelSuspendedJobPostResponse
func (c *ClientWithResponses) CancelSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) CancelSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *CancelSuspendedJobPostParams, body CancelSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelSuspendedJobPostResponse, error) {
	rsp, err := c.CancelSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelSuspendedJobPostResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// GetSuspendedJobFlowWithResponse request returning *GetSuspendedJobFlowResponse
func (c *ClientWithResponses) GetSuspendedJobFlowWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *GetSuspendedJobFlowParams, reqEditors ...RequestEditorFn) (*GetSuspendedJobFlowResponse, error) {
	rsp, err := c.GetSuspendedJobFlow(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSuspendedJobFlowResponse(rsp)
}

// GetJobUpdatesWithResponse request returning *GetJobUpdatesResponse
func (c *ClientWithResponses) GetJobUpdatesWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, params *GetJobUpdatesParams, reqEditors ...RequestEditorFn) (*GetJobUpdatesResponse, error) {
	rsp, err := c.GetJobUpdates(ctx, workspace, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobUpdatesResponse(rsp)
}

// CancelQueuedJobWithBodyWithResponse request with arbitrary body returning *CancelQueuedJobResponse
func (c *ClientWithResponses) CancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) CancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body CancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelQueuedJobResponse, error) {
	rsp, err := c.CancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueuedJobResponse(rsp)
}

// ForceCancelQueuedJobWithBodyWithResponse request with arbitrary body returning *ForceCancelQueuedJobResponse
func (c *ClientWithResponses) ForceCancelQueuedJobWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJobWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

func (c *ClientWithResponses) ForceCancelQueuedJobWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, body ForceCancelQueuedJobJSONRequestBody, reqEditors ...RequestEditorFn) (*ForceCancelQueuedJobResponse, error) {
	rsp, err := c.ForceCancelQueuedJob(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForceCancelQueuedJobResponse(rsp)
}

// ResumeSuspendedJobGetWithResponse request returning *ResumeSuspendedJobGetResponse
func (c *ClientWithResponses) ResumeSuspendedJobGetWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobGetParams, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobGetResponse, error) {
	rsp, err := c.ResumeSuspendedJobGet(ctx, workspace, id, resumeId, signature, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobGetResponse(rsp)
}

// ResumeSuspendedJobPostWithBodyWithResponse request with arbitrary body returning *ResumeSuspendedJobPostResponse
func (c *ClientWithResponses) ResumeSuspendedJobPostWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPostWithBody(ctx, workspace, id, resumeId, signature, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

func (c *ClientWithResponses) ResumeSuspendedJobPostWithResponse(ctx context.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params *ResumeSuspendedJobPostParams, body ResumeSuspendedJobPostJSONRequestBody, reqEditors ...RequestEditorFn) (*ResumeSuspendedJobPostResponse, error) {
	rsp, err := c.ResumeSuspendedJobPost(ctx, workspace, id, resumeId, signature, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSuspendedJobPostResponse(rsp)
}

// ConnectSlackCallbackWithBodyWithResponse request with arbitrary body returning *ConnectSlackCallbackResponse
func (c *ClientWithResponses) ConnectSlackCallbackWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallbackWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

func (c *ClientWithResponses) ConnectSlackCallbackWithResponse(ctx context.Context, workspace WorkspaceId, body ConnectSlackCallbackJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectSlackCallbackResponse, error) {
	rsp, err := c.ConnectSlackCallback(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectSlackCallbackResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, workspace WorkspaceId, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// DisconnectAccountWithResponse request returning *DisconnectAccountResponse
func (c *ClientWithResponses) DisconnectAccountWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, reqEditors ...RequestEditorFn) (*DisconnectAccountResponse, error) {
	rsp, err := c.DisconnectAccount(ctx, workspace, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectAccountResponse(rsp)
}

// DisconnectSlackWithResponse request returning *DisconnectSlackResponse
func (c *ClientWithResponses) DisconnectSlackWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DisconnectSlackResponse, error) {
	rsp, err := c.DisconnectSlack(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisconnectSlackResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, workspace, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, workspace WorkspaceId, id AccountId, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshToken(ctx, workspace, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

// CreateResourceWithBodyWithResponse request with arbitrary body returning *CreateResourceResponse
func (c *ClientWithResponses) CreateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResourceWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResource(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

// DeleteResourceWithResponse request returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// ExistsResourceWithResponse request returning *ExistsResourceResponse
func (c *ClientWithResponses) ExistsResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceResponse, error) {
	rsp, err := c.ExistsResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetResourceValueWithResponse request returning *GetResourceValueResponse
func (c *ClientWithResponses) GetResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceValueResponse, error) {
	rsp, err := c.GetResourceValue(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceValueResponse(rsp)
}

// ListResourceWithResponse request returning *ListResourceResponse
func (c *ClientWithResponses) ListResourceWithResponse(ctx context.Context, workspace WorkspaceId, params *ListResourceParams, reqEditors ...RequestEditorFn) (*ListResourceResponse, error) {
	rsp, err := c.ListResource(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceResponse(rsp)
}

// CreateResourceTypeWithBodyWithResponse request with arbitrary body returning *CreateResourceTypeResponse
func (c *ClientWithResponses) CreateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceTypeWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, body CreateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceTypeResponse, error) {
	rsp, err := c.CreateResourceType(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceTypeResponse(rsp)
}

// DeleteResourceTypeWithResponse request returning *DeleteResourceTypeResponse
func (c *ClientWithResponses) DeleteResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteResourceTypeResponse, error) {
	rsp, err := c.DeleteResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceTypeResponse(rsp)
}

// ExistsResourceTypeWithResponse request returning *ExistsResourceTypeResponse
func (c *ClientWithResponses) ExistsResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsResourceTypeResponse, error) {
	rsp, err := c.ExistsResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsResourceTypeResponse(rsp)
}

// GetResourceTypeWithResponse request returning *GetResourceTypeResponse
func (c *ClientWithResponses) GetResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetResourceTypeResponse, error) {
	rsp, err := c.GetResourceType(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceTypeResponse(rsp)
}

// ListResourceTypeWithResponse request returning *ListResourceTypeResponse
func (c *ClientWithResponses) ListResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeResponse, error) {
	rsp, err := c.ListResourceType(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeResponse(rsp)
}

// ListResourceTypeNamesWithResponse request returning *ListResourceTypeNamesResponse
func (c *ClientWithResponses) ListResourceTypeNamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListResourceTypeNamesResponse, error) {
	rsp, err := c.ListResourceTypeNames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResourceTypeNamesResponse(rsp)
}

// UpdateResourceTypeWithBodyWithResponse request with arbitrary body returning *UpdateResourceTypeResponse
func (c *ClientWithResponses) UpdateResourceTypeWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceTypeWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceTypeWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceTypeResponse, error) {
	rsp, err := c.UpdateResourceType(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceTypeResponse(rsp)
}

// UpdateResourceWithBodyWithResponse request with arbitrary body returning *UpdateResourceResponse
func (c *ClientWithResponses) UpdateResourceWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResourceWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceResponse, error) {
	rsp, err := c.UpdateResource(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceResponse(rsp)
}

// UpdateResourceValueWithBodyWithResponse request with arbitrary body returning *UpdateResourceValueResponse
func (c *ClientWithResponses) UpdateResourceValueWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValueWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

func (c *ClientWithResponses) UpdateResourceValueWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateResourceValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResourceValueResponse, error) {
	rsp, err := c.UpdateResourceValue(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResourceValueResponse(rsp)
}

// CreateScheduleWithBodyWithResponse request with arbitrary body returning *CreateScheduleResponse
func (c *ClientWithResponses) CreateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateScheduleWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScheduleResponse, error) {
	rsp, err := c.CreateSchedule(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScheduleResponse(rsp)
}

// DeleteScheduleWithResponse request returning *DeleteScheduleResponse
func (c *ClientWithResponses) DeleteScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteScheduleResponse, error) {
	rsp, err := c.DeleteSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScheduleResponse(rsp)
}

// ExistsScheduleWithResponse request returning *ExistsScheduleResponse
func (c *ClientWithResponses) ExistsScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsScheduleResponse, error) {
	rsp, err := c.ExistsSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScheduleResponse(rsp)
}

// GetScheduleWithResponse request returning *GetScheduleResponse
func (c *ClientWithResponses) GetScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*GetScheduleResponse, error) {
	rsp, err := c.GetSchedule(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleResponse(rsp)
}

// ListSchedulesWithResponse request returning *ListSchedulesResponse
func (c *ClientWithResponses) ListSchedulesWithResponse(ctx context.Context, workspace WorkspaceId, params *ListSchedulesParams, reqEditors ...RequestEditorFn) (*ListSchedulesResponse, error) {
	rsp, err := c.ListSchedules(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesResponse(rsp)
}

// SetScheduleEnabledWithBodyWithResponse request with arbitrary body returning *SetScheduleEnabledResponse
func (c *ClientWithResponses) SetScheduleEnabledWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabledWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

func (c *ClientWithResponses) SetScheduleEnabledWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body SetScheduleEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEnabledResponse, error) {
	rsp, err := c.SetScheduleEnabled(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEnabledResponse(rsp)
}

// UpdateScheduleWithBodyWithResponse request with arbitrary body returning *UpdateScheduleResponse
func (c *ClientWithResponses) UpdateScheduleWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateScheduleWithBody(ctx, workspace, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateScheduleWithResponse(ctx context.Context, workspace WorkspaceId, path Path, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateSchedule(ctx, workspace, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

// ArchiveScriptByHashWithResponse request returning *ArchiveScriptByHashResponse
func (c *ClientWithResponses) ArchiveScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*ArchiveScriptByHashResponse, error) {
	rsp, err := c.ArchiveScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByHashResponse(rsp)
}

// ArchiveScriptByPathWithResponse request returning *ArchiveScriptByPathResponse
func (c *ClientWithResponses) ArchiveScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ArchiveScriptByPathResponse, error) {
	rsp, err := c.ArchiveScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveScriptByPathResponse(rsp)
}

// CreateScriptWithBodyWithResponse request with arbitrary body returning *CreateScriptResponse
func (c *ClientWithResponses) CreateScriptWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScriptWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

func (c *ClientWithResponses) CreateScriptWithResponse(ctx context.Context, workspace WorkspaceId, body CreateScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScriptResponse, error) {
	rsp, err := c.CreateScript(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScriptResponse(rsp)
}

// DeleteScriptByHashWithResponse request returning *DeleteScriptByHashResponse
func (c *ClientWithResponses) DeleteScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*DeleteScriptByHashResponse, error) {
	rsp, err := c.DeleteScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByHashResponse(rsp)
}

// DeleteScriptByPathWithResponse request returning *DeleteScriptByPathResponse
func (c *ClientWithResponses) DeleteScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*DeleteScriptByPathResponse, error) {
	rsp, err := c.DeleteScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScriptByPathResponse(rsp)
}

// GetScriptDeploymentStatusWithResponse request returning *GetScriptDeploymentStatusResponse
func (c *ClientWithResponses) GetScriptDeploymentStatusWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptDeploymentStatusResponse, error) {
	rsp, err := c.GetScriptDeploymentStatus(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptDeploymentStatusResponse(rsp)
}

// ExistsScriptByPathWithResponse request returning *ExistsScriptByPathResponse
func (c *ClientWithResponses) ExistsScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*ExistsScriptByPathResponse, error) {
	rsp, err := c.ExistsScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsScriptByPathResponse(rsp)
}

// GetScriptByHashWithResponse request returning *GetScriptByHashResponse
func (c *ClientWithResponses) GetScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, hash ScriptHash, reqEditors ...RequestEditorFn) (*GetScriptByHashResponse, error) {
	rsp, err := c.GetScriptByHash(ctx, workspace, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByHashResponse(rsp)
}

// GetScriptByPathWithResponse request returning *GetScriptByPathResponse
func (c *ClientWithResponses) GetScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*GetScriptByPathResponse, error) {
	rsp, err := c.GetScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScriptByPathResponse(rsp)
}

// ListScriptsWithResponse request returning *ListScriptsResponse
func (c *ClientWithResponses) ListScriptsWithResponse(ctx context.Context, workspace WorkspaceId, params *ListScriptsParams, reqEditors ...RequestEditorFn) (*ListScriptsResponse, error) {
	rsp, err := c.ListScripts(ctx, workspace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptsResponse(rsp)
}

// ListScriptPathsWithResponse request returning *ListScriptPathsResponse
func (c *ClientWithResponses) ListScriptPathsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListScriptPathsResponse, error) {
	rsp, err := c.ListScriptPaths(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScriptPathsResponse(rsp)
}

// RawScriptByHashWithResponse request returning *RawScriptByHashResponse
func (c *ClientWithResponses) RawScriptByHashWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByHashResponse, error) {
	rsp, err := c.RawScriptByHash(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByHashResponse(rsp)
}

// RawScriptByPathWithResponse request returning *RawScriptByPathResponse
func (c *ClientWithResponses) RawScriptByPathWithResponse(ctx context.Context, workspace WorkspaceId, path ScriptPath, reqEditors ...RequestEditorFn) (*RawScriptByPathResponse, error) {
	rsp, err := c.RawScriptByPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawScriptByPathResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, workspace WorkspaceId, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// IsOwnerOfPathWithResponse request returning *IsOwnerOfPathResponse
func (c *ClientWithResponses) IsOwnerOfPathWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*IsOwnerOfPathResponse, error) {
	rsp, err := c.IsOwnerOfPath(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsOwnerOfPathResponse(rsp)
}

// LeaveWorkspaceWithResponse request returning *LeaveWorkspaceResponse
func (c *ClientWithResponses) LeaveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*LeaveWorkspaceResponse, error) {
	rsp, err := c.LeaveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveWorkspaceResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// ListUsernamesWithResponse request returning *ListUsernamesResponse
func (c *ClientWithResponses) ListUsernamesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListUsernamesResponse, error) {
	rsp, err := c.ListUsernames(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsernamesResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, username string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, workspace, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, workspace WorkspaceId, username string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, workspace, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// WhoisWithResponse request returning *WhoisResponse
func (c *ClientWithResponses) WhoisWithResponse(ctx context.Context, workspace WorkspaceId, username string, reqEditors ...RequestEditorFn) (*WhoisResponse, error) {
	rsp, err := c.Whois(ctx, workspace, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWhoisResponse(rsp)
}

// CreateVariableWithBodyWithResponse request with arbitrary body returning *CreateVariableResponse
func (c *ClientWithResponses) CreateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariableWithBody(ctx, workspace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

func (c *ClientWithResponses) CreateVariableWithResponse(ctx context.Context, workspace WorkspaceId, params *CreateVariableParams, body CreateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVariableResponse, error) {
	rsp, err := c.CreateVariable(ctx, workspace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVariableResponse(rsp)
}

// DeleteVariableWithResponse request returning *DeleteVariableResponse
func (c *ClientWithResponses) DeleteVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*DeleteVariableResponse, error) {
	rsp, err := c.DeleteVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVariableResponse(rsp)
}

// ExistsVariableWithResponse request returning *ExistsVariableResponse
func (c *ClientWithResponses) ExistsVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, reqEditors ...RequestEditorFn) (*ExistsVariableResponse, error) {
	rsp, err := c.ExistsVariable(ctx, workspace, path, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsVariableResponse(rsp)
}

// GetVariableWithResponse request returning *GetVariableResponse
func (c *ClientWithResponses) GetVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *GetVariableParams, reqEditors ...RequestEditorFn) (*GetVariableResponse, error) {
	rsp, err := c.GetVariable(ctx, workspace, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVariableResponse(rsp)
}

// ListVariableWithResponse request returning *ListVariableResponse
func (c *ClientWithResponses) ListVariableWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListVariableResponse, error) {
	rsp, err := c.ListVariable(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVariableResponse(rsp)
}

// ListContextualVariablesWithResponse request returning *ListContextualVariablesResponse
func (c *ClientWithResponses) ListContextualVariablesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListContextualVariablesResponse, error) {
	rsp, err := c.ListContextualVariables(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContextualVariablesResponse(rsp)
}

// UpdateVariableWithBodyWithResponse request with arbitrary body returning *UpdateVariableResponse
func (c *ClientWithResponses) UpdateVariableWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariableWithBody(ctx, workspace, path, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

func (c *ClientWithResponses) UpdateVariableWithResponse(ctx context.Context, workspace WorkspaceId, path Path, params *UpdateVariableParams, body UpdateVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVariableResponse, error) {
	rsp, err := c.UpdateVariable(ctx, workspace, path, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVariableResponse(rsp)
}

// AddUserWithBodyWithResponse request with arbitrary body returning *AddUserResponse
func (c *ClientWithResponses) AddUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

func (c *ClientWithResponses) AddUserWithResponse(ctx context.Context, workspace WorkspaceId, body AddUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserResponse, error) {
	rsp, err := c.AddUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserResponse(rsp)
}

// ArchiveWorkspaceWithResponse request returning *ArchiveWorkspaceResponse
func (c *ClientWithResponses) ArchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ArchiveWorkspaceResponse, error) {
	rsp, err := c.ArchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkspaceResponse(rsp)
}

// DeleteInviteWithBodyWithResponse request with arbitrary body returning *DeleteInviteResponse
func (c *ClientWithResponses) DeleteInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

func (c *ClientWithResponses) DeleteInviteWithResponse(ctx context.Context, workspace WorkspaceId, body DeleteInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteInviteResponse, error) {
	rsp, err := c.DeleteInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResponse(rsp)
}

// EditAutoInviteWithBodyWithResponse request with arbitrary body returning *EditAutoInviteResponse
func (c *ClientWithResponses) EditAutoInviteWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInviteWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

func (c *ClientWithResponses) EditAutoInviteWithResponse(ctx context.Context, workspace WorkspaceId, body EditAutoInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAutoInviteResponse, error) {
	rsp, err := c.EditAutoInvite(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAutoInviteResponse(rsp)
}

// EditSlackCommandWithBodyWithResponse request with arbitrary body returning *EditSlackCommandResponse
func (c *ClientWithResponses) EditSlackCommandWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommandWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

func (c *ClientWithResponses) EditSlackCommandWithResponse(ctx context.Context, workspace WorkspaceId, body EditSlackCommandJSONRequestBody, reqEditors ...RequestEditorFn) (*EditSlackCommandResponse, error) {
	rsp, err := c.EditSlackCommand(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditSlackCommandResponse(rsp)
}

// EditWebhookWithBodyWithResponse request with arbitrary body returning *EditWebhookResponse
func (c *ClientWithResponses) EditWebhookWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhookWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

func (c *ClientWithResponses) EditWebhookWithResponse(ctx context.Context, workspace WorkspaceId, body EditWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*EditWebhookResponse, error) {
	rsp, err := c.EditWebhook(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditWebhookResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResponse
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, workspace WorkspaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUserWithBody(ctx, workspace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, workspace WorkspaceId, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResponse, error) {
	rsp, err := c.InviteUser(ctx, workspace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResponse(rsp)
}

// ListPendingInvitesWithResponse request returning *ListPendingInvitesResponse
func (c *ClientWithResponses) ListPendingInvitesWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*ListPendingInvitesResponse, error) {
	rsp, err := c.ListPendingInvites(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPendingInvitesResponse(rsp)
}

// GetPremiumInfoWithResponse request returning *GetPremiumInfoResponse
func (c *ClientWithResponses) GetPremiumInfoWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*GetPremiumInfoResponse, error) {
	rsp, err := c.GetPremiumInfo(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPremiumInfoResponse(rsp)
}

// ListWorkersWithResponse request returning *ListWorkersResponse
func (c *ClientWithResponses) ListWorkersWithResponse(ctx context.Context, params *ListWorkersParams, reqEditors ...RequestEditorFn) (*ListWorkersResponse, error) {
	rsp, err := c.ListWorkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkersResponse(rsp)
}

// IsDomainAllowedWithResponse request returning *IsDomainAllowedResponse
func (c *ClientWithResponses) IsDomainAllowedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsDomainAllowedResponse, error) {
	rsp, err := c.IsDomainAllowed(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsDomainAllowedResponse(rsp)
}

// CreateWorkspaceWithBodyWithResponse request with arbitrary body returning *CreateWorkspaceResponse
func (c *ClientWithResponses) CreateWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkspaceWithResponse(ctx context.Context, body CreateWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkspaceResponse, error) {
	rsp, err := c.CreateWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkspaceResponse(rsp)
}

// DeleteWorkspaceWithResponse request returning *DeleteWorkspaceResponse
func (c *ClientWithResponses) DeleteWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	rsp, err := c.DeleteWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWorkspaceResponse(rsp)
}

// ExistsWorkspaceWithBodyWithResponse request with arbitrary body returning *ExistsWorkspaceResponse
func (c *ClientWithResponses) ExistsWorkspaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) ExistsWorkspaceWithResponse(ctx context.Context, body ExistsWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsWorkspaceResponse, error) {
	rsp, err := c.ExistsWorkspace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsWorkspaceResponse(rsp)
}

// ExistsUsernameWithBodyWithResponse request with arbitrary body returning *ExistsUsernameResponse
func (c *ClientWithResponses) ExistsUsernameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsernameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

func (c *ClientWithResponses) ExistsUsernameWithResponse(ctx context.Context, body ExistsUsernameJSONRequestBody, reqEditors ...RequestEditorFn) (*ExistsUsernameResponse, error) {
	rsp, err := c.ExistsUsername(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExistsUsernameResponse(rsp)
}

// ListWorkspacesWithResponse request returning *ListWorkspacesResponse
func (c *ClientWithResponses) ListWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkspacesResponse, error) {
	rsp, err := c.ListWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesResponse(rsp)
}

// ListWorkspacesAsSuperAdminWithResponse request returning *ListWorkspacesAsSuperAdminResponse
func (c *ClientWithResponses) ListWorkspacesAsSuperAdminWithResponse(ctx context.Context, params *ListWorkspacesAsSuperAdminParams, reqEditors ...RequestEditorFn) (*ListWorkspacesAsSuperAdminResponse, error) {
	rsp, err := c.ListWorkspacesAsSuperAdmin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspacesAsSuperAdminResponse(rsp)
}

// UnarchiveWorkspaceWithResponse request returning *UnarchiveWorkspaceResponse
func (c *ClientWithResponses) UnarchiveWorkspaceWithResponse(ctx context.Context, workspace WorkspaceId, reqEditors ...RequestEditorFn) (*UnarchiveWorkspaceResponse, error) {
	rsp, err := c.UnarchiveWorkspace(ctx, workspace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkspaceResponse(rsp)
}

// ListUserWorkspacesWithResponse request returning *ListUserWorkspacesResponse
func (c *ClientWithResponses) ListUserWorkspacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error) {
	rsp, err := c.ListUserWorkspaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserWorkspacesResponse(rsp)
}

// ParseGetHubAppByIdResponse parses an HTTP response from a GetHubAppByIdWithResponse call
func ParseGetHubAppByIdResponse(rsp *http.Response) (*GetHubAppByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubAppByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			App struct {
				Summary string      `json:"summary"`
				Value   interface{} `json:"value"`
			} `json:"app"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubAppsResponse parses an HTTP response from a ListHubAppsWithResponse call
func ParseListHubAppsResponse(rsp *http.Response) (*ListHubAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps *[]struct {
				AppId    float32  `json:"app_id"`
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"apps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHubFlowByIdResponse parses an HTTP response from a GetHubFlowByIdWithResponse call
func ParseGetHubFlowByIdResponse(rsp *http.Response) (*GetHubFlowByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubFlowByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flow *OpenFlow `json:"flow,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubFlowsResponse parses an HTTP response from a ListHubFlowsWithResponse call
func ParseListHubFlowsResponse(rsp *http.Response) (*ListHubFlowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flows *[]struct {
				Approved bool     `json:"approved"`
				Apps     []string `json:"apps"`
				FlowId   float32  `json:"flow_id"`
				Id       float32  `json:"id"`
				Summary  string   `json:"summary"`
				Votes    float32  `json:"votes"`
			} `json:"flows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConnectCallbackResponse parses an HTTP response from a ConnectCallbackWithResponse call
func ParseConnectCallbackResponse(rsp *http.Response) (*ConnectCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthConnectsResponse parses an HTTP response from a ListOAuthConnectsWithResponse call
func ParseListOAuthConnectsResponse(rsp *http.Response) (*ListOAuthConnectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthConnectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]struct {
				ExtraParams *interface{} `json:"extra_params,omitempty"`
				Scopes      *[]string    `json:"scopes,omitempty"`
			} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOAuthLoginsResponse parses an HTTP response from a ListOAuthLoginsWithResponse call
func ParseListOAuthLoginsResponse(rsp *http.Response) (*ListOAuthLoginsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOAuthLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginWithOauthResponse parses an HTTP response from a LoginWithOauthWithResponse call
func ParseLoginWithOauthResponse(rsp *http.Response) (*LoginWithOauthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginWithOauthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenApiYamlResponse parses an HTTP response from a GetOpenApiYamlWithResponse call
func ParseGetOpenApiYamlResponse(rsp *http.Response) (*GetOpenApiYamlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenApiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePreviewScheduleResponse parses an HTTP response from a PreviewScheduleWithResponse call
func ParsePreviewScheduleResponse(rsp *http.Response) (*PreviewScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []time.Time
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBashToJsonschemaResponse parses an HTTP response from a BashToJsonschemaWithResponse call
func ParseBashToJsonschemaResponse(rsp *http.Response) (*BashToJsonschemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BashToJsonschemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainArgSignature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDenoToJsonschemaResponse parses an HTTP response from a DenoToJsonschemaWithResponse call
func ParseDenoToJsonschemaResponse(rsp *http.Response) (*DenoToJsonschemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DenoToJsonschemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainArgSignature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGoToJsonschemaResponse parses an HTTP response from a GoToJsonschemaWithResponse call
func ParseGoToJsonschemaResponse(rsp *http.Response) (*GoToJsonschemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GoToJsonschemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainArgSignature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHubScriptContentByPathResponse parses an HTTP response from a GetHubScriptContentByPathWithResponse call
func ParseGetHubScriptContentByPathResponse(rsp *http.Response) (*GetHubScriptContentByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptContentByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHubScriptByPathResponse parses an HTTP response from a GetHubScriptByPathWithResponse call
func ParseGetHubScriptByPathResponse(rsp *http.Response) (*GetHubScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content  string       `json:"content"`
			Language string       `json:"language"`
			Lockfile *string      `json:"lockfile,omitempty"`
			Schema   *interface{} `json:"schema,omitempty"`
			Summary  *string      `json:"summary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHubScriptsResponse parses an HTTP response from a ListHubScriptsWithResponse call
func ParseListHubScriptsResponse(rsp *http.Response) (*ListHubScriptsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHubScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Asks *[]struct {
				App      string  `json:"app"`
				Approved bool    `json:"approved"`
				AskId    float32 `json:"ask_id"`
				Id       float32 `json:"id"`
				Kind     string  `json:"kind"`
				Summary  string  `json:"summary"`
				Views    float32 `json:"views"`
				Votes    float32 `json:"votes"`
			} `json:"asks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePythonToJsonschemaResponse parses an HTTP response from a PythonToJsonschemaWithResponse call
func ParsePythonToJsonschemaResponse(rsp *http.Response) (*PythonToJsonschemaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PythonToJsonschemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MainArgSignature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRawScriptByPathTokenedResponse parses an HTTP response from a RawScriptByPathTokenedWithResponse call
func ParseRawScriptByPathTokenedResponse(rsp *http.Response) (*RawScriptByPathTokenedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathTokenedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAcceptInviteResponse parses an HTTP response from a AcceptInviteWithResponse call
func ParseAcceptInviteResponse(rsp *http.Response) (*AcceptInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateUserGloballyResponse parses an HTTP response from a CreateUserGloballyWithResponse call
func ParseCreateUserGloballyResponse(rsp *http.Response) (*CreateUserGloballyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserGloballyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeclineInviteResponse parses an HTTP response from a DeclineInviteWithResponse call
func ParseDeclineInviteResponse(rsp *http.Response) (*DeclineInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeclineInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalUserDeleteResponse parses an HTTP response from a GlobalUserDeleteWithResponse call
func ParseGlobalUserDeleteResponse(rsp *http.Response) (*GlobalUserDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCurrentEmailResponse parses an HTTP response from a GetCurrentEmailWithResponse call
func ParseGetCurrentEmailResponse(rsp *http.Response) (*GetCurrentEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUsersAsSuperAdminResponse parses an HTTP response from a ListUsersAsSuperAdminWithResponse call
func ParseListUsersAsSuperAdminResponse(rsp *http.Response) (*ListUsersAsSuperAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspaceInvitesResponse parses an HTTP response from a ListWorkspaceInvitesWithResponse call
func ParseListWorkspaceInvitesResponse(rsp *http.Response) (*ListWorkspaceInvitesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetPasswordResponse parses an HTTP response from a SetPasswordWithResponse call
func ParseSetPasswordResponse(rsp *http.Response) (*SetPasswordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTokenImpersonateResponse parses an HTTP response from a CreateTokenImpersonateWithResponse call
func ParseCreateTokenImpersonateResponse(rsp *http.Response) (*CreateTokenImpersonateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenImpersonateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TruncatedToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalUserUpdateResponse parses an HTTP response from a GlobalUserUpdateWithResponse call
func ParseGlobalUserUpdateResponse(rsp *http.Response) (*GlobalUserUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalUserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUsageResponse parses an HTTP response from a GetUsageWithResponse call
func ParseGetUsageResponse(rsp *http.Response) (*GetUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGlobalWhoamiResponse parses an HTTP response from a GlobalWhoamiWithResponse call
func ParseGlobalWhoamiResponse(rsp *http.Response) (*GlobalWhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalWhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalUserInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBackendVersionResponse parses an HTTP response from a BackendVersionWithResponse call
func ParseBackendVersionResponse(rsp *http.Response) (*BackendVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackendVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddGranularAclsResponse parses an HTTP response from a AddGranularAclsWithResponse call
func ParseAddGranularAclsResponse(rsp *http.Response) (*AddGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGranularAclsResponse parses an HTTP response from a GetGranularAclsWithResponse call
func ParseGetGranularAclsResponse(rsp *http.Response) (*GetGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]bool `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveGranularAclsResponse parses an HTTP response from a RemoveGranularAclsWithResponse call
func ParseRemoveGranularAclsResponse(rsp *http.Response) (*RemoveGranularAclsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveGranularAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsAppResponse parses an HTTP response from a ExistsAppWithResponse call
func ParseExistsAppResponse(rsp *http.Response) (*ExistsAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByPathResponse parses an HTTP response from a GetAppByPathWithResponse call
func ParseGetAppByPathResponse(rsp *http.Response) (*GetAppByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppByVersionResponse parses an HTTP response from a GetAppByVersionWithResponse call
func ParseGetAppByVersionResponse(rsp *http.Response) (*GetAppByVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPublicSecretOfAppResponse parses an HTTP response from a GetPublicSecretOfAppWithResponse call
func ParseGetPublicSecretOfAppResponse(rsp *http.Response) (*GetPublicSecretOfAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicSecretOfAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExecuteComponentResponse parses an HTTP response from a ExecuteComponentWithResponse call
func ParseExecuteComponentResponse(rsp *http.Response) (*ExecuteComponentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPublicAppBySecretResponse parses an HTTP response from a GetPublicAppBySecretWithResponse call
func ParseGetPublicAppBySecretResponse(rsp *http.Response) (*GetPublicAppBySecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPublicAppBySecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppWithLastVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuditLogResponse parses an HTTP response from a GetAuditLogWithResponse call
func ParseGetAuditLogResponse(rsp *http.Response) (*GetAuditLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResponse parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResponse(rsp *http.Response) (*ListAuditLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCaptureResponse parses an HTTP response from a GetCaptureWithResponse call
func ParseGetCaptureResponse(rsp *http.Response) (*GetCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCaptureResponse parses an HTTP response from a CreateCaptureWithResponse call
func ParseCreateCaptureResponse(rsp *http.Response) (*CreateCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateCaptureResponse parses an HTTP response from a UpdateCaptureWithResponse call
func ParseUpdateCaptureResponse(rsp *http.Response) (*UpdateCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStarResponse parses an HTTP response from a StarWithResponse call
func ParseStarResponse(rsp *http.Response) (*StarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUnstarResponse parses an HTTP response from a UnstarWithResponse call
func ParseUnstarResponse(rsp *http.Response) (*UnstarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnstarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveFlowByPathResponse parses an HTTP response from a ArchiveFlowByPathWithResponse call
func ParseArchiveFlowByPathResponse(rsp *http.Response) (*ArchiveFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFlowResponse parses an HTTP response from a CreateFlowWithResponse call
func ParseCreateFlowResponse(rsp *http.Response) (*CreateFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFlowByPathResponse parses an HTTP response from a DeleteFlowByPathWithResponse call
func ParseDeleteFlowByPathResponse(rsp *http.Response) (*DeleteFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsFlowByPathResponse parses an HTTP response from a ExistsFlowByPathWithResponse call
func ParseExistsFlowByPathResponse(rsp *http.Response) (*ExistsFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowByPathResponse parses an HTTP response from a GetFlowByPathWithResponse call
func ParseGetFlowByPathResponse(rsp *http.Response) (*GetFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowInputHistoryByPathResponse parses an HTTP response from a GetFlowInputHistoryByPathWithResponse call
func ParseGetFlowInputHistoryByPathResponse(rsp *http.Response) (*GetFlowInputHistoryByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowInputHistoryByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFlowsResponse parses an HTTP response from a ListFlowsWithResponse call
func ParseListFlowsResponse(rsp *http.Response) (*ListFlowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFlowPathsResponse parses an HTTP response from a ListFlowPathsWithResponse call
func ParseListFlowPathsResponse(rsp *http.Response) (*ListFlowPathsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFlowResponse parses an HTTP response from a UpdateFlowWithResponse call
func ParseUpdateFlowResponse(rsp *http.Response) (*UpdateFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddOwnerToFolderResponse parses an HTTP response from a AddOwnerToFolderWithResponse call
func ParseAddOwnerToFolderResponse(rsp *http.Response) (*AddOwnerToFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFolderResponse parses an HTTP response from a CreateFolderWithResponse call
func ParseCreateFolderResponse(rsp *http.Response) (*CreateFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFolderResponse parses an HTTP response from a GetFolderWithResponse call
func ParseGetFolderResponse(rsp *http.Response) (*GetFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFolderUsageResponse parses an HTTP response from a GetFolderUsageWithResponse call
func ParseGetFolderUsageResponse(rsp *http.Response) (*GetFolderUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps      float32 `json:"apps"`
			Flows     float32 `json:"flows"`
			Resources float32 `json:"resources"`
			Schedules float32 `json:"schedules"`
			Scripts   float32 `json:"scripts"`
			Variables float32 `json:"variables"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFoldersResponse parses an HTTP response from a ListFoldersWithResponse call
func ParseListFoldersResponse(rsp *http.Response) (*ListFoldersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFolderNamesResponse parses an HTTP response from a ListFolderNamesWithResponse call
func ParseListFolderNamesResponse(rsp *http.Response) (*ListFolderNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFolderNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveOwnerToFolderResponse parses an HTTP response from a RemoveOwnerToFolderWithResponse call
func ParseRemoveOwnerToFolderResponse(rsp *http.Response) (*RemoveOwnerToFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveOwnerToFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateFolderResponse parses an HTTP response from a UpdateFolderWithResponse call
func ParseUpdateFolderResponse(rsp *http.Response) (*UpdateFolderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddUserToGroupResponse parses an HTTP response from a AddUserToGroupWithResponse call
func ParseAddUserToGroupResponse(rsp *http.Response) (*AddUserToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGroupNamesResponse parses an HTTP response from a ListGroupNamesWithResponse call
func ParseListGroupNamesResponse(rsp *http.Response) (*ListGroupNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveUserToGroupResponse parses an HTTP response from a RemoveUserToGroupWithResponse call
func ParseRemoveUserToGroupResponse(rsp *http.Response) (*RemoveUserToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateInputResponse parses an HTTP response from a CreateInputWithResponse call
func ParseCreateInputResponse(rsp *http.Response) (*CreateInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInputResponse parses an HTTP response from a DeleteInputWithResponse call
func ParseDeleteInputResponse(rsp *http.Response) (*DeleteInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetInputHistoryResponse parses an HTTP response from a GetInputHistoryWithResponse call
func ParseGetInputHistoryResponse(rsp *http.Response) (*GetInputHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInputHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInputsResponse parses an HTTP response from a ListInputsWithResponse call
func ParseListInputsResponse(rsp *http.Response) (*ListInputsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Input
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateInputResponse parses an HTTP response from a UpdateInputWithResponse call
func ParseUpdateInputResponse(rsp *http.Response) (*UpdateInputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCompletedJobResponse parses an HTTP response from a DeleteCompletedJobWithResponse call
func ParseDeleteCompletedJobResponse(rsp *http.Response) (*DeleteCompletedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResponse parses an HTTP response from a GetCompletedJobWithResponse call
func ParseGetCompletedJobResponse(rsp *http.Response) (*GetCompletedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCompletedJobResultResponse parses an HTTP response from a GetCompletedJobResultWithResponse call
func ParseGetCompletedJobResultResponse(rsp *http.Response) (*GetCompletedJobResultResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompletedJobResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCompletedJobsResponse parses an HTTP response from a ListCompletedJobsWithResponse call
func ParseListCompletedJobsResponse(rsp *http.Response) (*ListCompletedJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCompletedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CompletedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResumeSuspendedFlowAsOwnerResponse parses an HTTP response from a ResumeSuspendedFlowAsOwnerWithResponse call
func ParseResumeSuspendedFlowAsOwnerResponse(rsp *http.Response) (*ResumeSuspendedFlowAsOwnerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedFlowAsOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateJobSignatureResponse parses an HTTP response from a CreateJobSignatureWithResponse call
func ParseCreateJobSignatureResponse(rsp *http.Response) (*CreateJobSignatureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobSignatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListQueueResponse parses an HTTP response from a ListQueueWithResponse call
func ParseListQueueResponse(rsp *http.Response) (*ListQueueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []QueuedJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResultByIdResponse parses an HTTP response from a ResultByIdWithResponse call
func ParseResultByIdResponse(rsp *http.Response) (*ResultByIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResultByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResumeUrlsResponse parses an HTTP response from a GetResumeUrlsWithResponse call
func ParseGetResumeUrlsResponse(rsp *http.Response) (*GetResumeUrlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResumeUrlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ApprovalPage string `json:"approvalPage"`
			Cancel       string `json:"cancel"`
			Resume       string `json:"resume"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunFlowByPathResponse parses an HTTP response from a RunFlowByPathWithResponse call
func ParseRunFlowByPathResponse(rsp *http.Response) (*RunFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByHashResponse parses an HTTP response from a RunScriptByHashWithResponse call
func ParseRunScriptByHashResponse(rsp *http.Response) (*RunScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptByPathResponse parses an HTTP response from a RunScriptByPathWithResponse call
func ParseRunScriptByPathResponse(rsp *http.Response) (*RunScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunScriptPreviewResponse parses an HTTP response from a RunScriptPreviewWithResponse call
func ParseRunScriptPreviewResponse(rsp *http.Response) (*RunScriptPreviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunScriptPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunFlowPreviewResponse parses an HTTP response from a RunFlowPreviewWithResponse call
func ParseRunFlowPreviewResponse(rsp *http.Response) (*RunFlowPreviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFlowPreviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRunWaitResultFlowByPathResponse parses an HTTP response from a RunWaitResultFlowByPathWithResponse call
func ParseRunWaitResultFlowByPathResponse(rsp *http.Response) (*RunWaitResultFlowByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultFlowByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathGetResponse parses an HTTP response from a RunWaitResultScriptByPathGetWithResponse call
func ParseRunWaitResultScriptByPathGetResponse(rsp *http.Response) (*RunWaitResultScriptByPathGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunWaitResultScriptByPathResponse parses an HTTP response from a RunWaitResultScriptByPathWithResponse call
func ParseRunWaitResultScriptByPathResponse(rsp *http.Response) (*RunWaitResultScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunWaitResultScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelSuspendedJobGetResponse parses an HTTP response from a CancelSuspendedJobGetWithResponse call
func ParseCancelSuspendedJobGetResponse(rsp *http.Response) (*CancelSuspendedJobGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCancelSuspendedJobPostResponse parses an HTTP response from a CancelSuspendedJobPostWithResponse call
func ParseCancelSuspendedJobPostResponse(rsp *http.Response) (*CancelSuspendedJobPostResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSuspendedJobFlowResponse parses an HTTP response from a GetSuspendedJobFlowWithResponse call
func ParseGetSuspendedJobFlowResponse(rsp *http.Response) (*GetSuspendedJobFlowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSuspendedJobFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Approvers []struct {
				Approver string `json:"approver"`
				ResumeId int    `json:"resume_id"`
			} `json:"approvers"`
			Job Job `json:"job"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJobUpdatesResponse parses an HTTP response from a GetJobUpdatesWithResponse call
func ParseGetJobUpdatesResponse(rsp *http.Response) (*GetJobUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Completed *bool   `json:"completed,omitempty"`
			MemPeak   *int    `json:"mem_peak,omitempty"`
			NewLogs   *string `json:"new_logs,omitempty"`
			Running   *bool   `json:"running,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelQueuedJobResponse parses an HTTP response from a CancelQueuedJobWithResponse call
func ParseCancelQueuedJobResponse(rsp *http.Response) (*CancelQueuedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseForceCancelQueuedJobResponse parses an HTTP response from a ForceCancelQueuedJobWithResponse call
func ParseForceCancelQueuedJobResponse(rsp *http.Response) (*ForceCancelQueuedJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForceCancelQueuedJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedJobGetResponse parses an HTTP response from a ResumeSuspendedJobGetWithResponse call
func ParseResumeSuspendedJobGetResponse(rsp *http.Response) (*ResumeSuspendedJobGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResumeSuspendedJobPostResponse parses an HTTP response from a ResumeSuspendedJobPostWithResponse call
func ParseResumeSuspendedJobPostResponse(rsp *http.Response) (*ResumeSuspendedJobPostResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSuspendedJobPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseConnectSlackCallbackResponse parses an HTTP response from a ConnectSlackCallbackWithResponse call
func ParseConnectSlackCallbackResponse(rsp *http.Response) (*ConnectSlackCallbackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectSlackCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectAccountResponse parses an HTTP response from a DisconnectAccountWithResponse call
func ParseDisconnectAccountResponse(rsp *http.Response) (*DisconnectAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisconnectSlackResponse parses an HTTP response from a DisconnectSlackWithResponse call
func ParseDisconnectSlackResponse(rsp *http.Response) (*DisconnectSlackResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisconnectSlackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRefreshTokenResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenResponse(rsp *http.Response) (*RefreshTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateResourceResponse parses an HTTP response from a CreateResourceWithResponse call
func ParseCreateResourceResponse(rsp *http.Response) (*CreateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsResourceResponse parses an HTTP response from a ExistsResourceWithResponse call
func ParseExistsResourceResponse(rsp *http.Response) (*ExistsResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceValueResponse parses an HTTP response from a GetResourceValueWithResponse call
func ParseGetResourceValueResponse(rsp *http.Response) (*GetResourceValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceResponse parses an HTTP response from a ListResourceWithResponse call
func ParseListResourceResponse(rsp *http.Response) (*ListResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateResourceTypeResponse parses an HTTP response from a CreateResourceTypeWithResponse call
func ParseCreateResourceTypeResponse(rsp *http.Response) (*CreateResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteResourceTypeResponse parses an HTTP response from a DeleteResourceTypeWithResponse call
func ParseDeleteResourceTypeResponse(rsp *http.Response) (*DeleteResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsResourceTypeResponse parses an HTTP response from a ExistsResourceTypeWithResponse call
func ParseExistsResourceTypeResponse(rsp *http.Response) (*ExistsResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceTypeResponse parses an HTTP response from a GetResourceTypeWithResponse call
func ParseGetResourceTypeResponse(rsp *http.Response) (*GetResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeResponse parses an HTTP response from a ListResourceTypeWithResponse call
func ParseListResourceTypeResponse(rsp *http.Response) (*ListResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ResourceType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResourceTypeNamesResponse parses an HTTP response from a ListResourceTypeNamesWithResponse call
func ParseListResourceTypeNamesResponse(rsp *http.Response) (*ListResourceTypeNamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResourceTypeNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResourceTypeResponse parses an HTTP response from a UpdateResourceTypeWithResponse call
func ParseUpdateResourceTypeResponse(rsp *http.Response) (*UpdateResourceTypeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceResponse parses an HTTP response from a UpdateResourceWithResponse call
func ParseUpdateResourceResponse(rsp *http.Response) (*UpdateResourceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateResourceValueResponse parses an HTTP response from a UpdateResourceValueWithResponse call
func ParseUpdateResourceValueResponse(rsp *http.Response) (*UpdateResourceValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResourceValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScheduleResponse parses an HTTP response from a CreateScheduleWithResponse call
func ParseCreateScheduleResponse(rsp *http.Response) (*CreateScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScheduleResponse parses an HTTP response from a DeleteScheduleWithResponse call
func ParseDeleteScheduleResponse(rsp *http.Response) (*DeleteScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsScheduleResponse parses an HTTP response from a ExistsScheduleWithResponse call
func ParseExistsScheduleResponse(rsp *http.Response) (*ExistsScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScheduleResponse parses an HTTP response from a GetScheduleWithResponse call
func ParseGetScheduleResponse(rsp *http.Response) (*GetScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchedulesResponse parses an HTTP response from a ListSchedulesWithResponse call
func ParseListSchedulesResponse(rsp *http.Response) (*ListSchedulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Schedule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetScheduleEnabledResponse parses an HTTP response from a SetScheduleEnabledWithResponse call
func ParseSetScheduleEnabledResponse(rsp *http.Response) (*SetScheduleEnabledResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetScheduleEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateScheduleResponse parses an HTTP response from a UpdateScheduleWithResponse call
func ParseUpdateScheduleResponse(rsp *http.Response) (*UpdateScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveScriptByHashResponse parses an HTTP response from a ArchiveScriptByHashWithResponse call
func ParseArchiveScriptByHashResponse(rsp *http.Response) (*ArchiveScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveScriptByPathResponse parses an HTTP response from a ArchiveScriptByPathWithResponse call
func ParseArchiveScriptByPathResponse(rsp *http.Response) (*ArchiveScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateScriptResponse parses an HTTP response from a CreateScriptWithResponse call
func ParseCreateScriptResponse(rsp *http.Response) (*CreateScriptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteScriptByHashResponse parses an HTTP response from a DeleteScriptByHashWithResponse call
func ParseDeleteScriptByHashResponse(rsp *http.Response) (*DeleteScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteScriptByPathResponse parses an HTTP response from a DeleteScriptByPathWithResponse call
func ParseDeleteScriptByPathResponse(rsp *http.Response) (*DeleteScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptDeploymentStatusResponse parses an HTTP response from a GetScriptDeploymentStatusWithResponse call
func ParseGetScriptDeploymentStatusResponse(rsp *http.Response) (*GetScriptDeploymentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Lock          *string `json:"lock,omitempty"`
			LockErrorLogs *string `json:"lock_error_logs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExistsScriptByPathResponse parses an HTTP response from a ExistsScriptByPathWithResponse call
func ParseExistsScriptByPathResponse(rsp *http.Response) (*ExistsScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByHashResponse parses an HTTP response from a GetScriptByHashWithResponse call
func ParseGetScriptByHashResponse(rsp *http.Response) (*GetScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScriptByPathResponse parses an HTTP response from a GetScriptByPathWithResponse call
func ParseGetScriptByPathResponse(rsp *http.Response) (*GetScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScriptsResponse parses an HTTP response from a ListScriptsWithResponse call
func ParseListScriptsResponse(rsp *http.Response) (*ListScriptsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Script
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScriptPathsResponse parses an HTTP response from a ListScriptPathsWithResponse call
func ParseListScriptPathsResponse(rsp *http.Response) (*ListScriptPathsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScriptPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRawScriptByHashResponse parses an HTTP response from a RawScriptByHashWithResponse call
func ParseRawScriptByHashResponse(rsp *http.Response) (*RawScriptByHashResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRawScriptByPathResponse parses an HTTP response from a RawScriptByPathWithResponse call
func ParseRawScriptByPathResponse(rsp *http.Response) (*RawScriptByPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawScriptByPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIsOwnerOfPathResponse parses an HTTP response from a IsOwnerOfPathWithResponse call
func ParseIsOwnerOfPathResponse(rsp *http.Response) (*IsOwnerOfPathResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsOwnerOfPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveWorkspaceResponse parses an HTTP response from a LeaveWorkspaceWithResponse call
func ParseLeaveWorkspaceResponse(rsp *http.Response) (*LeaveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUsernamesResponse parses an HTTP response from a ListUsernamesWithResponse call
func ParseListUsernamesResponse(rsp *http.Response) (*ListUsernamesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsernamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWhoisResponse parses an HTTP response from a WhoisWithResponse call
func ParseWhoisResponse(rsp *http.Response) (*WhoisResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WhoisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVariableResponse parses an HTTP response from a CreateVariableWithResponse call
func ParseCreateVariableResponse(rsp *http.Response) (*CreateVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteVariableResponse parses an HTTP response from a DeleteVariableWithResponse call
func ParseDeleteVariableResponse(rsp *http.Response) (*DeleteVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsVariableResponse parses an HTTP response from a ExistsVariableWithResponse call
func ParseExistsVariableResponse(rsp *http.Response) (*ExistsVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVariableResponse parses an HTTP response from a GetVariableWithResponse call
func ParseGetVariableResponse(rsp *http.Response) (*GetVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVariableResponse parses an HTTP response from a ListVariableWithResponse call
func ParseListVariableResponse(rsp *http.Response) (*ListVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListableVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListContextualVariablesResponse parses an HTTP response from a ListContextualVariablesWithResponse call
func ParseListContextualVariablesResponse(rsp *http.Response) (*ListContextualVariablesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContextualVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ContextualVariable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVariableResponse parses an HTTP response from a UpdateVariableWithResponse call
func ParseUpdateVariableResponse(rsp *http.Response) (*UpdateVariableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAddUserResponse parses an HTTP response from a AddUserWithResponse call
func ParseAddUserResponse(rsp *http.Response) (*AddUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseArchiveWorkspaceResponse parses an HTTP response from a ArchiveWorkspaceWithResponse call
func ParseArchiveWorkspaceResponse(rsp *http.Response) (*ArchiveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteInviteResponse parses an HTTP response from a DeleteInviteWithResponse call
func ParseDeleteInviteResponse(rsp *http.Response) (*DeleteInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditAutoInviteResponse parses an HTTP response from a EditAutoInviteWithResponse call
func ParseEditAutoInviteResponse(rsp *http.Response) (*EditAutoInviteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAutoInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditSlackCommandResponse parses an HTTP response from a EditSlackCommandWithResponse call
func ParseEditSlackCommandResponse(rsp *http.Response) (*EditSlackCommandResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditSlackCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEditWebhookResponse parses an HTTP response from a EditWebhookWithResponse call
func ParseEditWebhookResponse(rsp *http.Response) (*EditWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AutoInviteDomain   *string `json:"auto_invite_domain,omitempty"`
			AutoInviteOperator *bool   `json:"auto_invite_operator,omitempty"`
			CustomerId         *string `json:"customer_id,omitempty"`
			Plan               *string `json:"plan,omitempty"`
			SlackCommandScript *string `json:"slack_command_script,omitempty"`
			SlackName          *string `json:"slack_name,omitempty"`
			SlackTeamId        *string `json:"slack_team_id,omitempty"`
			Webhook            *string `json:"webhook,omitempty"`
			WorkspaceId        *string `json:"workspace_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteUserResponse parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResponse(rsp *http.Response) (*InviteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPendingInvitesResponse parses an HTTP response from a ListPendingInvitesWithResponse call
func ParseListPendingInvitesResponse(rsp *http.Response) (*ListPendingInvitesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPendingInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkspaceInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPremiumInfoResponse parses an HTTP response from a GetPremiumInfoWithResponse call
func ParseGetPremiumInfoResponse(rsp *http.Response) (*GetPremiumInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPremiumInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Premium bool     `json:"premium"`
			Usage   *float32 `json:"usage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkersResponse parses an HTTP response from a ListWorkersWithResponse call
func ParseListWorkersResponse(rsp *http.Response) (*ListWorkersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerPing
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIsDomainAllowedResponse parses an HTTP response from a IsDomainAllowedWithResponse call
func ParseIsDomainAllowedResponse(rsp *http.Response) (*IsDomainAllowedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsDomainAllowedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWorkspaceResponse parses an HTTP response from a CreateWorkspaceWithResponse call
func ParseCreateWorkspaceResponse(rsp *http.Response) (*CreateWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteWorkspaceResponse parses an HTTP response from a DeleteWorkspaceWithResponse call
func ParseDeleteWorkspaceResponse(rsp *http.Response) (*DeleteWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsWorkspaceResponse parses an HTTP response from a ExistsWorkspaceWithResponse call
func ParseExistsWorkspaceResponse(rsp *http.Response) (*ExistsWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExistsUsernameResponse parses an HTTP response from a ExistsUsernameWithResponse call
func ParseExistsUsernameResponse(rsp *http.Response) (*ExistsUsernameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExistsUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListWorkspacesResponse parses an HTTP response from a ListWorkspacesWithResponse call
func ParseListWorkspacesResponse(rsp *http.Response) (*ListWorkspacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkspacesAsSuperAdminResponse parses an HTTP response from a ListWorkspacesAsSuperAdminWithResponse call
func ParseListWorkspacesAsSuperAdminResponse(rsp *http.Response) (*ListWorkspacesAsSuperAdminResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspacesAsSuperAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkspaceResponse parses an HTTP response from a UnarchiveWorkspaceWithResponse call
func ParseUnarchiveWorkspaceResponse(rsp *http.Response) (*UnarchiveWorkspaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUserWorkspacesResponse parses an HTTP response from a ListUserWorkspacesWithResponse call
func ParseListUserWorkspacesResponse(rsp *http.Response) (*ListUserWorkspacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserWorkspaceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
